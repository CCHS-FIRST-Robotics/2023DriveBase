{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment 2023 Drive base }2023 Drive base}
{\comment Generated by doxygen 1.9.6.}
{\creatim \yr2023\mo1\dy17\hr11\min48\sec0}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt 2023 Drive base}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Tue Jan 17 2023 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
2023 Drive Base{\tc \v 2023 Drive Base}\par \pard\plain 
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 Project Board}\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Contributing
\par}
{\tc\tcl2 \v Contributing}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
The enviroment
\par}
{\tc\tcl3 \v The enviroment}
FIRST robotics projects are made in {\f2 Visual Studio Code}, with the wpilib extension. Look up "wpilib" in the extensions tab of vs-code once it is installed. Use {\f2 wpilib commands to build and deploy the code}.\par
Download the repository with {\f2 git clone {\f2 https://github.com/CCHS-FIRST-Robotics/2023DriveBase.git}} \par}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
How to add your amazing changes!
\par}
{\tc\tcl3 \v How to add your amazing changes!}
{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Run {\f2 doxygen}  to update the docs (how to install doxygen is in the "Adding documentation" section).\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab Create a branch: {\f2 git branch *name*}  (replace "\\*name\\*" with what changes you intend to make).\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab Track all of your new changes: {\f2 git add .} \par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
4.\tab Commit the changes: {\f2 git commit -m "*changes*"}  (replace "\\*changes\\*" with what changes you made)\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
5.\tab Push the commit to the repository: {\f2 git push} \par}
\par
{\f2 New to github?}\par}
\par}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Documentation
\par}
{\tc\tcl2 \v Documentation}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Adding documentation
\par}
{\tc\tcl3 \v Adding documentation}
The documentation pages and visuals are created by doxygen. The doxygen configuration is almost completely default, its file is "Doxygen" {\f2 learn more about doxygen}\par
When updating code, comments, or anything that should be in documentation, run {\f2 doxygen}  before commiting. Install Doxygen on mac with {\f2 Brew}: {\f2 brew install doxygen} \par
If you want to change the doxygen configuration, use the doxygen gui, {\f2 doxywizard}. Make sure you save the outputted doxygen config in the Doxygen file.\par}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
How the drive base works
\par}
{\tc\tcl3 \v How the drive base works}
The "heart" of the robot is the roborio, which uses wpilib for instructions. There are a couple {\f2 base robot templates}, but we are using the {\f2 TimedRobot} .\par
If you want to understand wpilib, start {\f2 here}. After that, you will need the {\f2 Java library documentation}.\par
Then, learn about our {\f2 drivebase code}.\par}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Motors and components
\par}
{\tc\tcl3 \v Motors and components}
Motors/motor controllers and other components of the robot will need other java libraries, and have other docs aswell.\par
We are using {\f2 Rev Robotics SparkMax} and {\f2 ctre Phoenix Talon and Victor} motor controllers (links are to their libraries).\par
The robot also uses a {\f2 NavX Gyro}. The gyro can get lots of information about the robot's orientation, position, etc.\par
When adding a new component, look up instructions on how to install it, and then update this doc with its library's documenation. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
WPILib-License{\tc \v WPILib-License}\par \pard\plain 
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2009-2021 FIRST and other WPILib contributors All rights reserved.\par
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Neither the name of FIRST, WPILib, nor the names of other WPILib contributors may be used to endorse or promote products derived from this software without specific prior written permission.\par}
\par
THIS SOFTWARE IS PROVIDED BY FIRST AND OTHER WPILIB CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY NONINFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FIRST OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Package List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the packages with brief descriptions (if available):}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b frc.robot} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b frc.robot.subsystems} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
frc.robot.Constants\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
frc.robot.subsystems.DriveBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
frc.robot.subsystems.MecaDrive\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
frc.robot.subsystems.TankDrive\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
frc.robot.Main\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
TimedRobot
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
frc.robot.Robot\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b frc.robot.Constants} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constants - set once, and use throught the code Naming convention is all caps, spaces are underscores LIKE_THIS })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b frc.robot.subsystems.DriveBase} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b frc.robot.Main} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Do NOT add any static variables to this class, or any initialization at all })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b frc.robot.subsystems.MecaDrive} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b frc.robot.Robot} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The VM is configured to automatically run this class, and to call the functions corresponding to each mode, as described in the TimedRobot documentation })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b frc.robot.subsystems.TankDrive} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages the tank drive base })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b robotics/2023DriveBase/src/main/java/frc/robot/{\b Constants.java} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b robotics/2023DriveBase/src/main/java/frc/robot/{\b Main.java} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b robotics/2023DriveBase/src/main/java/frc/robot/{\b Robot.java} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b robotics/2023DriveBase/src/main/java/frc/robot/subsystems/{\b DriveBase.java} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b robotics/2023DriveBase/src/main/java/frc/robot/subsystems/{\b MecaDrive.java} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b robotics/2023DriveBase/src/main/java/frc/robot/subsystems/{\b TankDrive.java} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Package frc.robot\par \pard\plain 
{\tc\tcl2 \v frc.robot}
{\xe \v frc.robot}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Packages\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
package {\b subsystems}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Constants}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constants - set once, and use throught the code Naming convention is all caps, spaces are underscores LIKE_THIS. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Main}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Do NOT add any static variables to this class, or any initialization at all. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Robot}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The VM is configured to automatically run this class, and to call the functions corresponding to each mode, as described in the TimedRobot documentation. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Package frc.robot.subsystems\par \pard\plain 
{\tc\tcl2 \v frc.robot.subsystems}
{\xe \v frc.robot.subsystems}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DriveBase}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MecaDrive}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TankDrive}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages the tank drive base. }}\par}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
frc.robot.Constants Class Reference\par \pard\plain 
{\tc\tcl2 \v frc.robot.Constants}
{\xe \v frc.robot.Constants}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constants - set once, and use throught the code Naming convention is all caps, spaces are underscores LIKE_THIS. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final int {\b XBOX_CONTROLLER_PORT} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final double {\b DRIVE_MAX_ANGULAR_VELOCITY} = 2 * Math.PI\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final double {\b TANK_WHEEL_RADIUS} = 0.075\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static double {\b maxVelocity}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final int {\b ENCODER_CPR} = 4096\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final double {\b dt} = 0.02\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final int {\b LEFT_VICTOR_ID} = 7\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final int {\b RIGHT_VICTOR_ID} = 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final int {\b TALON_ID} = 9\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final int {\b SPARK_MAX_ID} = 12\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final int {\b FR_TALON_PORT} = 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final int {\b FL_TALON_PORT} = 8\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final int {\b RR_TALON_PORT} = 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final int {\b RL_TALON_PORT} = 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final double {\b SPARK_MAX_CONVERSION_FACTOR} = (2 * Math.PI) / 60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final double {\b TALON_CONVERSION_FACTOR} = 10 * 2 * Math.PI / {\b ENCODER_CPR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final double {\b ANALOG_DEAD_ZONE} = 0.1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final double {\b ROBOT_WIDTH} = 0.40\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final double {\b SLOW_DOWN_CUTOFF} = 0.05\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final double {\b SLOW_DOWN_FACTOR} = 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constants - set once, and use throught the code Naming convention is all caps, spaces are underscores LIKE_THIS. \par
}{
Definition at line {\b 9} of file {\b Constants.java}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v ANALOG_DEAD_ZONE\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:ANALOG_DEAD_ZONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final double frc.robot.Constants.ANALOG_DEAD_ZONE = 0.1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.subsystems.MecaDrive.drive()}, and {\b frc.robot.subsystems.TankDrive.drive()}.}\par
}
{\xe \v DRIVE_MAX_ANGULAR_VELOCITY\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:DRIVE_MAX_ANGULAR_VELOCITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final double frc.robot.Constants.DRIVE_MAX_ANGULAR_VELOCITY = 2 * Math.PI{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b Constants.java}.}\par
}
{\xe \v dt\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:dt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final double frc.robot.Constants.dt = 0.02{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b Constants.java}.}\par
}
{\xe \v ENCODER_CPR\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:ENCODER_CPR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final int frc.robot.Constants.ENCODER_CPR = 4096{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.printPosition()}, and {\b frc.robot.subsystems.TankDrive.TankDrive()}.}\par
}
{\xe \v FL_TALON_PORT\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:FL_TALON_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final int frc.robot.Constants.FL_TALON_PORT = 8{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.createMecanumDrive()}.}\par
}
{\xe \v FR_TALON_PORT\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:FR_TALON_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final int frc.robot.Constants.FR_TALON_PORT = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.createMecanumDrive()}.}\par
}
{\xe \v LEFT_VICTOR_ID\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:LEFT_VICTOR_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final int frc.robot.Constants.LEFT_VICTOR_ID = 7{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.createTankDrive()}.}\par
}
{\xe \v maxVelocity\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:maxVelocity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double frc.robot.Constants.maxVelocity{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b Constants.java}.}\par
}
{\xe \v RIGHT_VICTOR_ID\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:RIGHT_VICTOR_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final int frc.robot.Constants.RIGHT_VICTOR_ID = 4{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.createTankDrive()}.}\par
}
{\xe \v RL_TALON_PORT\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:RL_TALON_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final int frc.robot.Constants.RL_TALON_PORT = 4{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.createMecanumDrive()}.}\par
}
{\xe \v ROBOT_WIDTH\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:ROBOT_WIDTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final double frc.robot.Constants.ROBOT_WIDTH = 0.40{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b Constants.java}.}\par
}
{\xe \v RR_TALON_PORT\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:RR_TALON_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final int frc.robot.Constants.RR_TALON_PORT = 10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.createMecanumDrive()}.}\par
}
{\xe \v SLOW_DOWN_CUTOFF\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:SLOW_DOWN_CUTOFF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final double frc.robot.Constants.SLOW_DOWN_CUTOFF = 0.05{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.slowDown()}, and {\b frc.robot.subsystems.MecaDrive.slowDown()}.}\par
}
{\xe \v SLOW_DOWN_FACTOR\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:SLOW_DOWN_FACTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final double frc.robot.Constants.SLOW_DOWN_FACTOR = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.slowDown()}, and {\b frc.robot.subsystems.MecaDrive.slowDown()}.}\par
}
{\xe \v SPARK_MAX_CONVERSION_FACTOR\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:SPARK_MAX_CONVERSION_FACTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final double frc.robot.Constants.SPARK_MAX_CONVERSION_FACTOR = (2 * Math.PI) / 60{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.drive()}.}\par
}
{\xe \v SPARK_MAX_ID\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:SPARK_MAX_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final int frc.robot.Constants.SPARK_MAX_ID = 12{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.createTankDrive()}.}\par
}
{\xe \v TALON_CONVERSION_FACTOR\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:TALON_CONVERSION_FACTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final double frc.robot.Constants.TALON_CONVERSION_FACTOR = 10 * 2 * Math.PI / {\b ENCODER_CPR}{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.drive()}.}\par
}
{\xe \v TALON_ID\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:TALON_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final int frc.robot.Constants.TALON_ID = 9{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.createTankDrive()}.}\par
}
{\xe \v TANK_WHEEL_RADIUS\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:TANK_WHEEL_RADIUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final double frc.robot.Constants.TANK_WHEEL_RADIUS = 0.075{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b Constants.java}.}\par
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.printPosition()}, and {\b frc.robot.subsystems.TankDrive.updatePosition()}.}\par
}
{\xe \v XBOX_CONTROLLER_PORT\:frc.robot.Constants}
{\xe \v frc.robot.Constants\:XBOX_CONTROLLER_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final int frc.robot.Constants.XBOX_CONTROLLER_PORT = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b Constants.java}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
robotics/2023DriveBase/src/main/java/frc/robot/{\b Constants.java}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
frc.robot.subsystems.DriveBase Class Reference\par \pard\plain 
{\tc\tcl2 \v frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
Inheritance diagram for frc.robot.subsystems.DriveBase:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "da/d95/classfrc_1_1robot_1_1subsystems_1_1_drive_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract void {\b drive} (double leftAnalogX, double leftAnalogY, double rightAnalogX, double rightAnalogY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Drive the robot with controller input. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b increaseSpeedBracket} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The speed bracket controls the multiplire for al the speeds So when you change it, lets say, to 1/2 speed, all movement will be at 1/2 speed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b decreaseSpeedBracket} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnOnDefaultMode} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnOnDebugMode} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnOnStopMode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
should be overridden for actual functionality because depends on drive base specifc speeds (for tank drive, there is a left and right speed, whereas for mecanum there are 4) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnONPIDTuningMode} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract void {\b cycleMotorDebugMode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Again needs to be implemented in sub classes becuase there might be different numbers of motors. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b BButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b YButtonPressed} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 4} of file {\b DriveBase.java}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AButtonPressed\:frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase\:AButtonPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.DriveBase.AButtonPressed ()}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b frc.robot.subsystems.TankDrive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 78} of file {\b DriveBase.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078 \{\}\par
}
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\xe \v BButtonPressed\:frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase\:BButtonPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.DriveBase.BButtonPressed ()}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b frc.robot.subsystems.TankDrive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 80} of file {\b DriveBase.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00080 \{\}\par
}
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\xe \v cycleMotorDebugMode\:frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase\:cycleMotorDebugMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract void frc.robot.subsystems.DriveBase.cycleMotorDebugMode (){\f2 [abstract]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Again needs to be implemented in sub classes becuase there might be different numbers of motors. }}\par
{
Reimplemented in {\b frc.robot.subsystems.MecaDrive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACU \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b frc.robot.subsystems.TankDrive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\xe \v decreaseSpeedBracket\:frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase\:decreaseSpeedBracket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.DriveBase.decreaseSpeedBracket ()}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b DriveBase.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00037                                        \{\par
00038         {\cf20 // the min is 0.2 because below that the robot is unlikely to move}\par
00039         speedMultiplier = Math.max(0.2, speedMultiplier - 0.1);\par
00040     \}\par
}
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\xe \v drive\:frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase\:drive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
abstract void frc.robot.subsystems.DriveBase.drive (double  {\i leftAnalogX}, double  {\i leftAnalogY}, double  {\i rightAnalogX}, double  {\i rightAnalogY}){\f2 [abstract]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Drive the robot with controller input. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These are doubles on the interval [-1, 1] and come from the controller's analog sticks \par
}{
Reimplemented in {\b frc.robot.subsystems.MecaDrive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b frc.robot.subsystems.TankDrive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\xe \v increaseSpeedBracket\:frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase\:increaseSpeedBracket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.DriveBase.increaseSpeedBracket ()}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The speed bracket controls the multiplire for al the speeds So when you change it, lets say, to 1/2 speed, all movement will be at 1/2 speed. }}\par
{
Definition at line {\b 33} of file {\b DriveBase.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00033                                        \{\par
00034         speedMultiplier = Math.min(1, speedMultiplier + 0.1);\par
00035     \}\par
}
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\xe \v turnOnDebugMode\:frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase\:turnOnDebugMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.DriveBase.turnOnDebugMode ()}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b DriveBase.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00048                                   \{\par
00049         {\cf19 if}(currentMode.equals(DEBUG_MODE)) {\cf19 return};\par
00050         currentMode = DEBUG_MODE;\par
00051         System.out.println({\cf22 "DEBUG MODE"});\par
00052     \}\par
}
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\xe \v turnOnDefaultMode\:frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase\:turnOnDefaultMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.DriveBase.turnOnDefaultMode ()}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b DriveBase.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00042                                     \{\par
00043         {\cf19 if}(currentMode.equals(DEFAULT_MODE)) {\cf19 return};\par
00044         currentMode = DEFAULT_MODE;\par
00045         System.out.println({\cf22 "DEFAULT MODE"});\par
00046     \}\par
}
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\xe \v turnONPIDTuningMode\:frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase\:turnONPIDTuningMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.DriveBase.turnONPIDTuningMode ()}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b DriveBase.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00065                                       \{\par
00066         {\cf19 if}(currentMode.equals(PID_TUNING_MODE)) {\cf19 return};\par
00067         currentMode = PID_TUNING_MODE;\par
00068         System.out.println({\cf22 "PID TUNING MODE"});\par
00069     \}\par
}
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\xe \v turnOnStopMode\:frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase\:turnOnStopMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.DriveBase.turnOnStopMode ()}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
should be overridden for actual functionality because depends on drive base specifc speeds (for tank drive, there is a left and right speed, whereas for mecanum there are 4) }}\par
{
Reimplemented in {\b frc.robot.subsystems.MecaDrive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADF \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b frc.robot.subsystems.TankDrive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 59} of file {\b DriveBase.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00059                                  \{\par
00060         {\cf19 if}(currentMode.equals(STOP_MODE)) {\cf19 return};\par
00061         currentMode = STOP_MODE;\par
00062         System.out.println({\cf22 "STOP MODE"});\par
00063     \}\par
}
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\xe \v XButtonPressed\:frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase\:XButtonPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.DriveBase.XButtonPressed ()}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b frc.robot.subsystems.TankDrive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 82} of file {\b DriveBase.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00082 \{\}\par
}
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\xe \v YButtonPressed\:frc.robot.subsystems.DriveBase}
{\xe \v frc.robot.subsystems.DriveBase\:YButtonPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.DriveBase.YButtonPressed ()}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b frc.robot.subsystems.TankDrive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 84} of file {\b DriveBase.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00084 \{\}\par
}
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
robotics/2023DriveBase/src/main/java/frc/robot/subsystems/{\b DriveBase.java}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
frc.robot.Main Class Reference\par \pard\plain 
{\tc\tcl2 \v frc.robot.Main}
{\xe \v frc.robot.Main}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Do NOT add any static variables to this class, or any initialization at all. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b main} (String... args)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main initialization function. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Do NOT add any static variables to this class, or any initialization at all. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unless you know what you are doing, do not modify this file except to change the parameter class to the startRobot call. \par
}{
Definition at line {\b 14} of file {\b Main.java}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Main\:frc.robot.Main}
{\xe \v frc.robot.Main\:Main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
frc.robot.Main.Main (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b Main.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00015 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v main\:frc.robot.Main}
{\xe \v frc.robot.Main\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void frc.robot.Main.main (String...  {\i args}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main initialization function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Do not perform any initialization here.\par
If you change your main robot class, change the parameter type. \par
}{
Definition at line {\b 22} of file {\b Main.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00022                                           \{\par
00023     RobotBase.startRobot(Robot::new);\par
00024   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
robotics/2023DriveBase/src/main/java/frc/robot/{\b Main.java}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
frc.robot.subsystems.MecaDrive Class Reference\par \pard\plain 
{\tc\tcl2 \v frc.robot.subsystems.MecaDrive}
{\xe \v frc.robot.subsystems.MecaDrive}
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
Inheritance diagram for frc.robot.subsystems.MecaDrive:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "d0/dd1/classfrc_1_1robot_1_1subsystems_1_1_meca_drive.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MecaDrive} (int frontLeftMotorPort, int frontRightMotorPort, int rearLeftMotorPort, int rearRightMotorPort)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for Mecanum Drive Class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drive} (double leftAnalogX, double leftAnalogY, double rightAnalogX, double rightAnalogY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
drive the robot using controller inputs }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnOnStopMode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
should be overridden for actual functionality because depends on drive base specifc speeds (for tank drive, there is a left and right speed, whereas for mecanum there are 4) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cycleMotorDebugMode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Again needs to be implemented in sub classes becuase there might be different numbers of motors. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b frc.robot.subsystems.DriveBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract void {\b drive} (double leftAnalogX, double leftAnalogY, double rightAnalogX, double rightAnalogY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Drive the robot with controller input. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b increaseSpeedBracket} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The speed bracket controls the multiplire for al the speeds So when you change it, lets say, to 1/2 speed, all movement will be at 1/2 speed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b decreaseSpeedBracket} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnOnDefaultMode} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnOnDebugMode} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnOnStopMode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
should be overridden for actual functionality because depends on drive base specifc speeds (for tank drive, there is a left and right speed, whereas for mecanum there are 4) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnONPIDTuningMode} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract void {\b cycleMotorDebugMode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Again needs to be implemented in sub classes becuase there might be different numbers of motors. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b BButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b YButtonPressed} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double[] {\b combineSpeeds} (double leftAnalogX, double leftAnalogY, double rightAnalogX, double rightAnalogY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the controller input into speeds for mecanum wheels. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double[] {\b slowDown} (double[] inputVelocity)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This will return a value lower than the input, and it is used to slow down the motors during stop mode. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 10} of file {\b MecaDrive.java}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MecaDrive\:frc.robot.subsystems.MecaDrive}
{\xe \v frc.robot.subsystems.MecaDrive\:MecaDrive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
frc.robot.subsystems.MecaDrive.MecaDrive (int  {\i frontLeftMotorPort}, int  {\i frontRightMotorPort}, int  {\i rearLeftMotorPort}, int  {\i rearRightMotorPort})}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for Mecanum Drive Class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i frontLeftMotorPort} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rearLeftMotorPort} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i frontRightMotorPort} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rearRightMotorPort} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 36} of file {\b MecaDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00037                                                                     \{\par
00038         frontLeftMotor = {\cf17 new} TalonSRX(frontLeftMotorPort);\par
00039         frontRightMotor = {\cf17 new} TalonSRX(frontRightMotorPort);\par
00040         rearLeftMotor = {\cf17 new} TalonSRX(rearLeftMotorPort);\par
00041         rearRightMotor = {\cf17 new} TalonSRX(rearRightMotorPort);\par
00042     \} \par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v combineSpeeds\:frc.robot.subsystems.MecaDrive}
{\xe \v frc.robot.subsystems.MecaDrive\:combineSpeeds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double[] frc.robot.subsystems.MecaDrive.combineSpeeds (double  {\i leftAnalogX}, double  {\i leftAnalogY}, double  {\i rightAnalogX}, double  {\i rightAnalogY}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the controller input into speeds for mecanum wheels. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i leftAnalogX} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i leftAnalogY} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rightAnalogX} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rightAnalogY} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
array of all processed speeds \{front left, front right, back left, back right\} \par
}}}{
Definition at line {\b 147} of file {\b MecaDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00148                                                                             \{\par
00149 \par
00150         leftAnalogY *= verticalSpeedMultiplier;\par
00151         leftAnalogX *= horizontalSPeedMultiplier;\par
00152        \par
00153         {\cf20 // arrays for wheel speeds (percents)}\par
00154         {\cf20 // 1st is front left, 2nd is front right, 3rd is back left, 4th is back right}\par
00155         {\cf18 double}[] verticalSpeeds = \{leftAnalogY, leftAnalogY,\par
00156                                    leftAnalogY, leftAnalogY\};\par
00157         \par
00158         {\cf20 // negatives due to wheels going in opposite directions during left or right translation}\par
00159         {\cf18 double}[] horizontalSpeeds = \{-1 * leftAnalogX, leftAnalogX,\par
00160                                      leftAnalogX, -1 * leftAnalogX\};\par
00161 \par
00162         {\cf20 // left and right wheels should go different directions to rotate the robot}\par
00163         {\cf18 double}[] rotationSpeeds = \{-1 * rightAnalogX, rightAnalogX,\par
00164                                    -1 * rightAnalogX, rightAnalogX\};\par
00165         \par
00166         {\cf20 // so these could exceed 1 (not good; we cannot run the motors at over 100%)}\par
00167         {\cf20 // we will use the maximum speed to scale all the other speeds to something below 1}\par
00168         {\cf19 for} ({\cf18 int} i = 0; i < 4; i ++)\par
00169             combinedSpeeds[i] = verticalSpeeds[i] + horizontalSpeeds[i] + rotationSpeeds[i];\par
00170 \par
00171         {\cf20 // find the max of the above speeds so we can check if it is above 1}\par
00172         {\cf18 double} maxSpeed = Integer.MIN_VALUE;\par
00173 \par
00174         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
00175             {\cf19 if} (Math.abs(combinedSpeeds[i]) > maxSpeed) maxSpeed = Math.abs(combinedSpeeds[i]);\par
00176         \par
00177         maxSpeed = Math.max(1, maxSpeed); {\cf20 // if it is under 1, we can basically ignore it    }\par
00178 \par
00179         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++) \{\par
00180             {\cf20 // scale the speeds}\par
00181             combinedSpeeds[i] = (1 / maxSpeed) * combinedSpeeds[i];\par
00182 \par
00183             {\cf20 // we also need to scale the speeds by the speed multiplier}\par
00184             combinedSpeeds[i] = combinedSpeeds[i] * speedMultiplier;\par
00185         \}\par
00186 \par
00187         {\cf19 return} combinedSpeeds;\par
00188     \}\par
}
{
\ql
Referenced by {\b frc.robot.subsystems.MecaDrive.drive()}.}\par
}
{\xe \v cycleMotorDebugMode\:frc.robot.subsystems.MecaDrive}
{\xe \v frc.robot.subsystems.MecaDrive\:cycleMotorDebugMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.MecaDrive.cycleMotorDebugMode ()}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Again needs to be implemented in sub classes becuase there might be different numbers of motors. }}\par
{
Reimplemented from {\b frc.robot.subsystems.DriveBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 224} of file {\b MecaDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00224                                       \{\par
00225         debugEnabledMotor++;\par
00226         debugEnabledMotor %= 4;\par
00227         System.out.println({\cf22 "Current Motor: "} + debugEnabledMotor);\par
00228     \}\par
}
}
{\xe \v drive\:frc.robot.subsystems.MecaDrive}
{\xe \v frc.robot.subsystems.MecaDrive\:drive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.MecaDrive.drive (double  {\i leftAnalogX}, double  {\i leftAnalogY}, double  {\i rightAnalogX}, double  {\i rightAnalogY})}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
drive the robot using controller inputs }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Left analog stick controls translation Right analog stick controls rotation (move it right -> rotate clockwise, move it left -> rotate counterclockwise)\par
positive is right/up\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i leftAnalogX} \cell }{the x position of the left analog stick; range: [-1, 1] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i leftAnalogY} \cell }{the y position of the left analog stick; range: [-1, 1] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rightAnalogX} \cell }{the x position of the right analog stick; range: [-1, 1] \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rightAnalogY} \cell }{the y position of the right analog stick; range: [-1, 1]\cell }
{\row }
}
Debug mode: {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid When you press the left stick down (left stick button) the robot enters\par
}
 debug mode (bool debugMode), and the robot will only move power one wheel at a time. Toggle through these wheels by pressing the left stick button more (FL -> FR -> BL -> BR) then, after BR, it will leave debug mode and go back into all wheel drive \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add deadzone (stop all movement when input is under a certain amount) Compare joystick distance from normal position (0)\par
}{
Reimplemented from {\b frc.robot.subsystems.DriveBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 66} of file {\b MecaDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00067                                                                 \{\par
00068         \par
00069         {\cf20 // left analog stick controls translation}\par
00070         {\cf20 // right analog stick controls rotation}\par
00071         \par
00072 {\cf20 }\par
00073 {\cf20          /**}\par
00074 {\cf20          * Add deadzone (stop all movement when input is under a certain amount)}\par
00075 {\cf20          * Compare joystick distance from normal position (0)}\par
00076 {\cf20          */}\par
00077         \par
00078         {\cf20 // Left analog joystick distance from origin from pythagoreas }\par
00079         {\cf18 double} leftJoystickDistance = Math.sqrt(Math.pow(leftAnalogX, 2) +\par
00080                                                 Math.pow(leftAnalogY, 2));\par
00081         {\cf19 if} (leftJoystickDistance < Constants.ANALOG_DEAD_ZONE) \{\par
00082             {\cf20 // joystick is within the deadzone, so set to 0}\par
00083             leftAnalogX = 0;\par
00084             leftAnalogY = 0;\par
00085         \}\par
00086         {\cf19 if} (rightAnalogX < Constants.ANALOG_DEAD_ZONE)\{\par
00087             rightAnalogX = 0;\par
00088         \}                   \par
00089 \par
00090         combinedSpeeds = combineSpeeds(leftAnalogX,  leftAnalogY, \par
00091                                        rightAnalogX, rightAnalogY);\par
00092 \par
00093         {\cf19 switch} (currentMode)\{\par
00094             {\cf19 case} DEFAULT_MODE:\par
00095                  {\cf20 // set the motor speeds (normal)}\par
00096                 frontLeftMotor.set(ControlMode.PercentOutput, combinedSpeeds[0] * -1);\par
00097                 frontRightMotor.set(ControlMode.PercentOutput, combinedSpeeds[1]);\par
00098                 rearLeftMotor.set(ControlMode.PercentOutput, combinedSpeeds[2] * -1);\par
00099                 rearRightMotor.set(ControlMode.PercentOutput, combinedSpeeds[3]);\par
00100                 {\cf19 break};\par
00101             {\cf19 case} STOP_MODE:\par
00102                 {\cf20 // STOP!!!!! set motors to 0}\par
00103                 {\cf20 // slower stop}\par
00104                 slowingDownSpeeds = slowDown(slowingDownSpeeds);\par
00105 \par
00106                 frontLeftMotor.set(ControlMode.PercentOutput, slowingDownSpeeds[0] * -1);\par
00107                 frontRightMotor.set(ControlMode.PercentOutput, slowingDownSpeeds[1]);\par
00108                 rearLeftMotor.set(ControlMode.PercentOutput, slowingDownSpeeds[2] * -1);\par
00109                 rearRightMotor.set(ControlMode.PercentOutput, slowingDownSpeeds[3]);\par
00110                 {\cf19 break};\par
00111             {\cf19 case} DEBUG_MODE:\par
00112                 {\cf20 // Debug mode (toggle wheels with left stick button)}\par
00113                 \par
00114                 {\cf19 switch} (debugEnabledMotor)\{\par
00115                     {\cf19 case} 0:\par
00116                         frontLeftMotor.set(ControlMode.PercentOutput, combinedSpeeds[0] * -1);\par
00117                         {\cf19 break};\par
00118                     {\cf19 case} 1:\par
00119                         frontRightMotor.set(ControlMode.PercentOutput, combinedSpeeds[1]);\par
00120                         {\cf19 break};\par
00121                     {\cf19 case} 2:\par
00122                         rearLeftMotor.set(ControlMode.PercentOutput, combinedSpeeds[2] * -1);\par
00123                         {\cf19 break};\par
00124                     {\cf19 case} 3:\par
00125                         rearRightMotor.set(ControlMode.PercentOutput, combinedSpeeds[3]);\par
00126                         {\cf19 break};  \par
00127                 \}\par
00128 \par
00129                 {\cf19 break};\par
00130             {\cf19 case} PID_TUNING_MODE:\par
00131                 {\cf20 // nothing yet}\par
00132                 {\cf19 break};\par
00133         \}\par
00134     \}\par
}
{
\ql
References {\b frc.robot.Constants.ANALOG_DEAD_ZONE}, {\b frc.robot.subsystems.MecaDrive.combineSpeeds()}, and {\b frc.robot.subsystems.MecaDrive.slowDown()}.}\par
}
{\xe \v slowDown\:frc.robot.subsystems.MecaDrive}
{\xe \v frc.robot.subsystems.MecaDrive\:slowDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double[] frc.robot.subsystems.MecaDrive.slowDown (double[]  {\i inputVelocity}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This will return a value lower than the input, and it is used to slow down the motors during stop mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i inputVelocity} \cell }{between -1 and 1 (double) \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the new value (lower) \par
}}}{
Definition at line {\b 197} of file {\b MecaDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00197                                                      \{\par
00198         {\cf20 // input is between -1 and 1}\par
00199         {\cf18 double}[] newVelocity = {\cf17 new} {\cf18 double}[4];\par
00200 \par
00201         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\{\par
00202             {\cf19 if} (Math.abs(inputVelocity[i]) > Constants.SLOW_DOWN_CUTOFF)\{\par
00203                 {\cf20 // velocity still needs to be reduced (magnatude is above cutoff)}\par
00204                 newVelocity[i] = inputVelocity[i] / Constants.SLOW_DOWN_FACTOR;\par
00205             \} {\cf19 else} \{\par
00206                 {\cf20 // input has reached cutoff, now returning 0 speed}\par
00207                 newVelocity[i] = 0;\par
00208             \}\par
00209         \}\par
00210         {\cf19 return} newVelocity;\par
00211     \}\par
}
{
\ql
References {\b frc.robot.Constants.SLOW_DOWN_CUTOFF}, and {\b frc.robot.Constants.SLOW_DOWN_FACTOR}.}\par
{
\ql
Referenced by {\b frc.robot.subsystems.MecaDrive.drive()}.}\par
}
{\xe \v turnOnStopMode\:frc.robot.subsystems.MecaDrive}
{\xe \v frc.robot.subsystems.MecaDrive\:turnOnStopMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.MecaDrive.turnOnStopMode ()}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
should be overridden for actual functionality because depends on drive base specifc speeds (for tank drive, there is a left and right speed, whereas for mecanum there are 4) }}\par
{
Reimplemented from {\b frc.robot.subsystems.DriveBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 214} of file {\b MecaDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00214                                  \{\par
00215         {\cf19 if}(currentMode.equals(STOP_MODE)) {\cf19 return};\par
00216         currentMode = STOP_MODE;\par
00217         {\cf20 // Stop mode activated, so now the robot needs to slow down}\par
00218         {\cf20 // start by saving the last left and right velocities }\par
00219         slowingDownSpeeds = combinedSpeeds;\par
00220         System.out.println({\cf22 "STOP MODE"});\par
00221     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
robotics/2023DriveBase/src/main/java/frc/robot/subsystems/{\b MecaDrive.java}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
frc.robot.Robot Class Reference\par \pard\plain 
{\tc\tcl2 \v frc.robot.Robot}
{\xe \v frc.robot.Robot}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The VM is configured to automatically run this class, and to call the functions corresponding to each mode, as described in the TimedRobot documentation. }}\par
Inheritance diagram for frc.robot.Robot:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/d54/classfrc_1_1robot_1_1_robot.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b robotInit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is run when the robot is first started up and should be used for any initialization code. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b robotPeriodic} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called every robot packet, no matter the mode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b autonomousInit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This autonomous (along with the chooser code above) shows how to select between different autonomous modes using the dashboard. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b autonomousPeriodic} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called periodically during autonomous. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b teleopInit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called once when teleop is enabled. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b teleopPeriodic} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called periodically during operator control. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b disabledInit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called once when the robot is disabled. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b disabledPeriodic} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called periodically when disabled. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testInit} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called once when test mode is enabled. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testPeriodic} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called periodically during test mode. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TankDrive} {\b createTankDrive} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MecaDrive} {\b createMecanumDrive} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b m_autoSelected}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
final SendableChooser< String > {\b m_chooser} = new SendableChooser<>()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XboxController {\b xboxController} = new XboxController({\b Constants.XBOX_CONTROLLER_PORT})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DriveBase} {\b driveBase}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final String {\b kDefaultAuto} = "Default"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static final String {\b kCustomAuto} = "My Auto"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The VM is configured to automatically run this class, and to call the functions corresponding to each mode, as described in the TimedRobot documentation. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you change the name of this class or the package after creating this project, you must also update the build.gradle file in the project. \par
}{
Definition at line {\b 20} of file {\b Robot.java}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v autonomousInit\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:autonomousInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.Robot.autonomousInit ()}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This autonomous (along with the chooser code above) shows how to select between different autonomous modes using the dashboard. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The sendable chooser code works with the Java SmartDashboard. If you prefer the LabVIEW Dashboard, remove all of the chooser code and uncomment the getString line to get the auto name from the text box below the Gyro\par
You can add additional auto modes by adding additional comparisons to the switch structure below with additional strings. If using the SendableChooser make sure to add them to the chooser code above as well. \par
}{
Definition at line {\b 74} of file {\b Robot.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00074                                \{\par
00075     m_autoSelected = m_chooser.getSelected();\par
00076     {\cf20 // m_autoSelected = SmartDashboard.getString("Auto Selector", kDefaultAuto);}\par
00077     System.out.println({\cf22 "Auto selected: "} + m_autoSelected);\par
00078   \}\par
}
{
\ql
References {\b frc.robot.Robot.m_autoSelected}, and {\b frc.robot.Robot.m_chooser}.}\par
}
{\xe \v autonomousPeriodic\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:autonomousPeriodic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.Robot.autonomousPeriodic ()}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called periodically during autonomous. }}\par
{
Definition at line {\b 82} of file {\b Robot.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00082                                    \{\par
00083     {\cf19 switch} (m_autoSelected) \{\par
00084       {\cf19 case} kCustomAuto:\par
00085         {\cf20 // Put custom auto code here}\par
00086         {\cf19 break};\par
00087       {\cf19 case} kDefaultAuto:\par
00088       {\cf19 default}:\par
00089         {\cf20 // Put default auto code here}\par
00090         {\cf19 break};\par
00091     \}\par
00092   \}\par
}
{
\ql
References {\b frc.robot.Robot.kCustomAuto}, {\b frc.robot.Robot.kDefaultAuto}, and {\b frc.robot.Robot.m_autoSelected}.}\par
}
{\xe \v createMecanumDrive\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:createMecanumDrive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MecaDrive} frc.robot.Robot.createMecanumDrive (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b Robot.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00165                                          \{\par
00166     {\cf19 return} {\cf17 new} MecaDrive(Constants.FL_TALON_PORT, Constants.FR_TALON_PORT,\par
00167                          Constants.RL_TALON_PORT, Constants.RR_TALON_PORT);\par
00168   \}\par
}
{
\ql
References {\b frc.robot.Constants.FL_TALON_PORT}, {\b frc.robot.Constants.FR_TALON_PORT}, {\b frc.robot.Constants.RL_TALON_PORT}, and {\b frc.robot.Constants.RR_TALON_PORT}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.robotInit()}.}\par
}
{\xe \v createTankDrive\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:createTankDrive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TankDrive} frc.robot.Robot.createTankDrive (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b Robot.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00160                                       \{\par
00161     {\cf19 return} {\cf17 new} TankDrive(Constants.SPARK_MAX_ID, Constants.LEFT_VICTOR_ID,\par
00162                          Constants.TALON_ID, Constants.RIGHT_VICTOR_ID);\par
00163   \}\par
}
{
\ql
References {\b frc.robot.Constants.LEFT_VICTOR_ID}, {\b frc.robot.Constants.RIGHT_VICTOR_ID}, {\b frc.robot.Constants.SPARK_MAX_ID}, and {\b frc.robot.Constants.TALON_ID}.}\par
}
{\xe \v disabledInit\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:disabledInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.Robot.disabledInit ()}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called once when the robot is disabled. }}\par
{
Definition at line {\b 146} of file {\b Robot.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00146 \{\}\par
}
}
{\xe \v disabledPeriodic\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:disabledPeriodic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.Robot.disabledPeriodic ()}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called periodically when disabled. }}\par
{
Definition at line {\b 149} of file {\b Robot.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00149 \{\}\par
}
}
{\xe \v robotInit\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:robotInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.Robot.robotInit ()}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is run when the robot is first started up and should be used for any initialization code. }}\par
{
Definition at line {\b 36} of file {\b Robot.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00036                           \{\par
00037     m_chooser.setDefaultOption({\cf22 "Default Auto"}, kDefaultAuto);\par
00038     m_chooser.addOption({\cf22 "My Auto"}, kCustomAuto);\par
00039     SmartDashboard.putData({\cf22 "Auto choices"}, m_chooser);\par
00040     CameraServer.startAutomaticCapture(0);\par
00041     CameraServer.startAutomaticCapture(1);\par
00042 \par
00043 \par
00044     {\cf20 // tank drive initialization}\par
00045     {\cf20 // driveBase = createTankDrive();    }\par
00046     {\cf20 // mecanum drive initialization}\par
00047     driveBase = createMecanumDrive();\par
00048     \par
00049     {\cf20 // // set the dead zone for the controller analog sticks}\par
00050     {\cf20 // driveBase.setDeadband(Constants.ANALOG_DEAD_ZONE);}\par
00051   \}\par
}
{
\ql
References {\b frc.robot.Robot.createMecanumDrive()}, {\b frc.robot.Robot.driveBase}, {\b frc.robot.Robot.kCustomAuto}, {\b frc.robot.Robot.kDefaultAuto}, and {\b frc.robot.Robot.m_chooser}.}\par
}
{\xe \v robotPeriodic\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:robotPeriodic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.Robot.robotPeriodic ()}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called every robot packet, no matter the mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use this for items like diagnostics that you want ran during disabled, autonomous, teleoperated and test.\par
This runs after the mode specific periodic functions, but before LiveWindow and SmartDashboard integrated updating. \par
}{
Definition at line {\b 61} of file {\b Robot.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00061 \{\}\par
}
}
{\xe \v teleopInit\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:teleopInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.Robot.teleopInit ()}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called once when teleop is enabled. }}\par
{
Definition at line {\b 96} of file {\b Robot.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00096 \{\}\par
}
}
{\xe \v teleopPeriodic\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:teleopPeriodic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.Robot.teleopPeriodic ()}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called periodically during operator control. }}\par
{
Definition at line {\b 100} of file {\b Robot.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00100                                \{\par
00101     {\cf20 // TODO: put the driving loop here}\par
00102     {\cf20 // TODO: check if buttons are pressed and comment controller mapping}\par
00103     {\cf19 if} (xboxController.getRightBumperPressed()) driveBase.increaseSpeedBracket();\par
00104     {\cf19 if} (xboxController.getLeftBumperPressed()) driveBase.decreaseSpeedBracket();\par
00105 \par
00106     {\cf20 // switch between modes (for DPad, 0 is up, and angles go clockwise, so 90 is right)}\par
00107     {\cf20 // up}\par
00108     {\cf19 if} (xboxController.getPOV() == 0) driveBase.turnOnDefaultMode();\par
00109     {\cf20 // right}\par
00110     {\cf19 if} (xboxController.getPOV() == 90) driveBase.turnOnStopMode();\par
00111     {\cf20 // left}\par
00112     {\cf19 if} (xboxController.getPOV() == 270) driveBase.turnOnDebugMode();\par
00113     {\cf20 // down}\par
00114     {\cf19 if} (xboxController.getPOV() == 180) driveBase.turnONPIDTuningMode();\par
00115 \par
00116 \par
00117     {\cf20 // Debug controls}\par
00118     {\cf19 if} (xboxController.getRightStickButtonPressed()) driveBase.cycleMotorDebugMode();\par
00119 \par
00120     {\cf20 // actions of the four button presses}\par
00121     {\cf19 if} (xboxController.getAButtonPressed()) \{\par
00122       driveBase.AButtonPressed();\par
00123     \}\par
00124     {\cf19 if} (xboxController.getBButtonPressed()) \{\par
00125       driveBase.BButtonPressed();\par
00126     \}\par
00127     {\cf19 if} (xboxController.getXButtonPressed()) \{\par
00128       driveBase.XButtonPressed();\par
00129     \}\par
00130     {\cf19 if} (xboxController.getYButtonPressed()) \{\par
00131       driveBase.YButtonPressed();\par
00132     \}\par
00133 \par
00134     {\cf20 // get analog input from xbox controller}\par
00135     {\cf18 double} leftAnalogX  = xboxController.getLeftX();\par
00136     {\cf18 double} leftAnalogY  = xboxController.getLeftY();\par
00137     {\cf18 double} rightAnalogX = xboxController.getRightX();\par
00138     {\cf18 double} rightAnalogY = xboxController.getRightY();\par
00139 \par
00140     {\cf20 // process input (determine wheelspeeds)}\par
00141     driveBase.drive(leftAnalogX, leftAnalogY, rightAnalogX, rightAnalogY);\par
00142   \}\par
}
{
\ql
References {\b frc.robot.subsystems.DriveBase.AButtonPressed()}, {\b frc.robot.subsystems.DriveBase.BButtonPressed()}, {\b frc.robot.subsystems.DriveBase.cycleMotorDebugMode()}, {\b frc.robot.subsystems.DriveBase.decreaseSpeedBracket()}, {\b frc.robot.subsystems.DriveBase.drive()}, {\b frc.robot.Robot.driveBase}, {\b frc.robot.subsystems.DriveBase.increaseSpeedBracket()}, {\b frc.robot.subsystems.DriveBase.turnOnDebugMode()}, {\b frc.robot.subsystems.DriveBase.turnOnDefaultMode()}, {\b frc.robot.subsystems.DriveBase.turnONPIDTuningMode()}, {\b frc.robot.subsystems.DriveBase.turnOnStopMode()}, {\b frc.robot.Robot.xboxController}, {\b frc.robot.subsystems.DriveBase.XButtonPressed()}, and {\b frc.robot.subsystems.DriveBase.YButtonPressed()}.}\par
}
{\xe \v testInit\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:testInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.Robot.testInit ()}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called once when test mode is enabled. }}\par
{
Definition at line {\b 153} of file {\b Robot.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00153 \{\}\par
}
}
{\xe \v testPeriodic\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:testPeriodic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.Robot.testPeriodic ()}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called periodically during test mode. }}\par
{
Definition at line {\b 157} of file {\b Robot.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00157 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v driveBase\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:driveBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DriveBase} frc.robot.Robot.driveBase{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b Robot.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.robotInit()}, and {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\xe \v kCustomAuto\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:kCustomAuto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final String frc.robot.Robot.kCustomAuto = "My Auto"{\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b Robot.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.autonomousPeriodic()}, and {\b frc.robot.Robot.robotInit()}.}\par
}
{\xe \v kDefaultAuto\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:kDefaultAuto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final String frc.robot.Robot.kDefaultAuto = "Default"{\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b Robot.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.autonomousPeriodic()}, and {\b frc.robot.Robot.robotInit()}.}\par
}
{\xe \v m_autoSelected\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:m_autoSelected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String frc.robot.Robot.m_autoSelected{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b Robot.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.autonomousInit()}, and {\b frc.robot.Robot.autonomousPeriodic()}.}\par
}
{\xe \v m_chooser\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:m_chooser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
final SendableChooser<String> frc.robot.Robot.m_chooser = new SendableChooser<>(){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b Robot.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.autonomousInit()}, and {\b frc.robot.Robot.robotInit()}.}\par
}
{\xe \v xboxController\:frc.robot.Robot}
{\xe \v frc.robot.Robot\:xboxController}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XboxController frc.robot.Robot.xboxController = new XboxController({\b Constants.XBOX_CONTROLLER_PORT}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b Robot.java}.}\par
{
\ql
Referenced by {\b frc.robot.Robot.teleopPeriodic()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
robotics/2023DriveBase/src/main/java/frc/robot/{\b Robot.java}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
frc.robot.subsystems.TankDrive Class Reference\par \pard\plain 
{\tc\tcl2 \v frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages the tank drive base. }}\par
Inheritance diagram for frc.robot.subsystems.TankDrive:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dd/ded/classfrc_1_1robot_1_1subsystems_1_1_tank_drive.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TankDrive} (int leftTalonPort, int leftVictorPort, int rightTalonPort, int rightVictorPort)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for TankDrive Class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b drive} (double leftAnalogX, double leftAnalogY, double rightAnalogX, double rightAnalogY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Drive the robot tank base from controller input. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnOnStopMode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
should be overridden for actual functionality because depends on drive base specifc speeds (for tank drive, there is a left and right speed, whereas for mecanum there are 4) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cycleMotorDebugMode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Again needs to be implemented in sub classes becuase there might be different numbers of motors. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateRobotVelocity} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getPosition} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updatePosition} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b BButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b YButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b incrementPIDConstant} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PID Tuning Mode: Increments the selected PID constant. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cyclePIDConstant} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PID Tuning Mode: Cycles between the PID constants. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toggleDecreasingPIDIncrement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printPIDConstants} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetPosition} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printPosition} ()\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b frc.robot.subsystems.DriveBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract void {\b drive} (double leftAnalogX, double leftAnalogY, double rightAnalogX, double rightAnalogY)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Drive the robot with controller input. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b increaseSpeedBracket} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The speed bracket controls the multiplire for al the speeds So when you change it, lets say, to 1/2 speed, all movement will be at 1/2 speed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b decreaseSpeedBracket} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnOnDefaultMode} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnOnDebugMode} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnOnStopMode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
should be overridden for actual functionality because depends on drive base specifc speeds (for tank drive, there is a left and right speed, whereas for mecanum there are 4) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b turnONPIDTuningMode} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
abstract void {\b cycleMotorDebugMode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Again needs to be implemented in sub classes becuase there might be different numbers of motors. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b BButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XButtonPressed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b YButtonPressed} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b slowDown} (double inputVelocity)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This will return a value lower than the input, and it is used to slow down the motors during stop mode. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages the tank drive base. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line {\b 26} of file {\b TankDrive.java}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v TankDrive\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:TankDrive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
frc.robot.subsystems.TankDrive.TankDrive (int  {\i leftTalonPort}, int  {\i leftVictorPort}, int  {\i rightTalonPort}, int  {\i rightVictorPort})}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for TankDrive Class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i leftMotorPort} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rightMotorPort} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 89} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00090                                                               \{\par
00091         leftVictor = {\cf17 new} VictorSPX(leftVictorPort);\par
00092         leftSparkMax = {\cf17 new} CANSparkMax(leftTalonPort, CANSparkMaxLowLevel.MotorType.kBrushed);\par
00093         rightTalon = {\cf17 new} TalonSRX(rightTalonPort);\par
00094         rightVictor = {\cf17 new} VictorSPX(rightVictorPort);\par
00095         sparkMaxEncoder = leftSparkMax.getEncoder(SparkMaxRelativeEncoder.Type.kQuadrature, Constants.ENCODER_CPR);\par
00096 \par
00097         currentMode = DEFAULT_MODE;\par
00098 \par
00099         leftPID = {\cf17 new} PIDController(PIDConstants[0], PIDConstants[1], PIDConstants[2]);\par
00100         rightPID = {\cf17 new} PIDController(PIDConstants[0], PIDConstants[1], PIDConstants[2]);\par
00101 \par
00102         navx = {\cf17 new} AHRS(SPI.Port.kMXP);\par
00103         odometer = {\cf17 new} DifferentialDriveOdometry({\cf17 new} Rotation2d());\par
00104         resetPosition();\par
00105     \}\par
}
{
\ql
References {\b frc.robot.Constants.ENCODER_CPR}, and {\b frc.robot.subsystems.TankDrive.resetPosition()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AButtonPressed\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:AButtonPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.AButtonPressed ()}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b frc.robot.subsystems.DriveBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 307} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00307                                  \{\par
00308         {\cf19 switch}(currentMode) \{\par
00309             {\cf19 case} DEFAULT_MODE:\par
00310                 printPosition();\par
00311                 {\cf19 break};\par
00312             {\cf19 case} DEBUG_MODE:\par
00313                 printPosition();    \par
00314                 {\cf19 break};\par
00315             {\cf19 case} STOP_MODE:\par
00316                 printPosition();    \par
00317                 {\cf19 break};\par
00318             {\cf19 case} PID_TUNING_MODE:\par
00319                 incrementPIDConstant();\par
00320                 {\cf19 break};\par
00321         \}\par
00322     \}\par
}
{
\ql
References {\b frc.robot.subsystems.TankDrive.incrementPIDConstant()}, and {\b frc.robot.subsystems.TankDrive.printPosition()}.}\par
}
{\xe \v BButtonPressed\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:BButtonPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.BButtonPressed ()}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b frc.robot.subsystems.DriveBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 325} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00325                                  \{\par
00326         {\cf19 switch}(currentMode) \{\par
00327             {\cf19 case} DEFAULT_MODE:\par
00328                 resetPosition();\par
00329                 {\cf19 break};\par
00330             {\cf19 case} DEBUG_MODE:\par
00331                 resetPosition();    \par
00332                 {\cf19 break};\par
00333             {\cf19 case} STOP_MODE:\par
00334                 resetPosition();\par
00335                 {\cf19 break};\par
00336             {\cf19 case} PID_TUNING_MODE:\par
00337                 cyclePIDConstant();\par
00338                 {\cf19 break};\par
00339         \}\par
00340     \}\par
}
{
\ql
References {\b frc.robot.subsystems.TankDrive.cyclePIDConstant()}, and {\b frc.robot.subsystems.TankDrive.resetPosition()}.}\par
}
{\xe \v cycleMotorDebugMode\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:cycleMotorDebugMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.cycleMotorDebugMode ()}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Again needs to be implemented in sub classes becuase there might be different numbers of motors. }}\par
{
Reimplemented from {\b frc.robot.subsystems.DriveBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 265} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00265                                       \{\par
00266         debugEnabledMotor++;\par
00267         debugEnabledMotor %= 4;\par
00268         System.out.println({\cf22 "Current Motor: "} + debugEnabledMotor);\par
00269     \}\par
}
}
{\xe \v cyclePIDConstant\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:cyclePIDConstant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.cyclePIDConstant ()}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PID Tuning Mode: Cycles between the PID constants. }}\par
{
Definition at line {\b 392} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00392                                    \{\par
00393         currentPIDConstant++;\par
00394         currentPIDConstant %= 3;\par
00395         {\cf19 if}(currentPIDConstant == 0) \{\par
00396             System.out.println({\cf22 "kP Selected"});\par
00397         \}\par
00398         {\cf19 else} {\cf19 if}(currentPIDConstant == 1) \{\par
00399             System.out.println({\cf22 "kI Selected"});\par
00400         \}\par
00401         {\cf19 else} {\cf19 if}(currentPIDConstant == 2) \{\par
00402             System.out.println({\cf22 "kD Selected"});\par
00403         \}\par
00404     \}\par
}
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.BButtonPressed()}.}\par
}
{\xe \v drive\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:drive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.drive (double  {\i leftAnalogX}, double  {\i leftAnalogY}, double  {\i rightAnalogX}, double  {\i rightAnalogY})}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Drive the robot tank base from controller input. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These are doubles on the interval [-1,1], and come from the controller's analog sticks (circle spinny things) {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i leftAnalogX} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i leftAnalogY} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rightAnalogX} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rightAnalogY} \cell }{\cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
we only care about left Y and right X left Y is average velocity right X is velocity difference between wheels\par
}{
Reimplemented from {\b frc.robot.subsystems.DriveBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 117} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00118                                                                 \{\par
00119 {\cf20 }\par
00120 {\cf20         /**}\par
00121 {\cf20          * we only care about left Y and right X}\par
00122 {\cf20          * left Y is average velocity}\par
00123 {\cf20          * right X is velocity difference between wheels}\par
00124 {\cf20         */}\par
00125 \par
00126         {\cf18 double} x = rightAnalogX; \par
00127         \par
00128         {\cf18 double} y = leftAnalogY;\par
00129 \par
00130         {\cf19 if}(Math.abs(x) < Constants.ANALOG_DEAD_ZONE && Math.abs(y) < Constants.ANALOG_DEAD_ZONE) {\cf19 return}; {\cf20 // deadzone}\par
00131 \par
00132         {\cf20 // make sure that both velocities are in [-1, 1]}\par
00133         {\cf18 double} preScaledLeftVel = y - x * rotationalSpeedMultiplier;\par
00134         {\cf18 double} preScaledRightVel = y + x * rotationalSpeedMultiplier;\par
00135         {\cf18 double} scaleFactor = 1 / Math.max(Math.max(Math.abs(preScaledLeftVel), Math.abs(preScaledRightVel)), 1);\par
00136         \par
00137         {\cf20 // scale to what the controller asks}\par
00138         leftVel = preScaledLeftVel * scaleFactor * speedMultiplier;\par
00139         rightVel = preScaledRightVel * scaleFactor * speedMultiplier;\par
00140         \par
00141         {\cf20 // // leftTalon.set(ControlMode.PercentOutput, leftVel);}\par
00142         {\cf20 // leftVictor.set(ControlMode.PercentOutput, leftVel);}\par
00143         {\cf20 // leftSparkMax.set(leftVel);}\par
00144         {\cf20 // rightTalon.set(ControlMode.PercentOutput, rightVel);}\par
00145         {\cf20 // rightVictor.set(ControlMode.PercentOutput, rightVel);}\par
00146         {\cf20 // set the motor speeds}\par
00147         {\cf19 if}(currentMode.equals(DEFAULT_MODE) || currentMode.equals(PID_TUNING_MODE)) \{\par
00148             leftVictor.set(ControlMode.PercentOutput, -1 *leftVel);\par
00149             leftSparkMax.set(leftVel);\par
00150             rightTalon.set(ControlMode.PercentOutput, rightVel);\par
00151             rightVictor.set(ControlMode.PercentOutput, rightVel);\par
00152 \par
00153 \par
00154 \par
00155             {\cf20 // PID stuff}\par
00156 \par
00157             {\cf20 // actual angular velocities converted to radians per second}\par
00158             {\cf18 double} leftAngVel = sparkMaxEncoder.getVelocity() * Constants.SPARK_MAX_CONVERSION_FACTOR;\par
00159             {\cf18 double} rightAngVel = rightTalon.getSelectedSensorVelocity() * Constants.TALON_CONVERSION_FACTOR;\par
00160 \par
00161             {\cf20 // normalized (actual) angular velocities}\par
00162             {\cf18 double} normalLeftAngVel = leftAngVel / maxAngularVel;\par
00163             {\cf18 double} normalRightAngVel = rightAngVel / maxAngularVel;\par
00164 \par
00165 \par
00166             {\cf20 // set the motors according to the PID}\par
00167             {\cf18 double} leftPIDValue = leftPID.calculate(normalLeftAngVel, leftVel);\par
00168             {\cf18 double} rightPIDValue = rightPID.calculate(normalRightAngVel, rightVel);\par
00169 \par
00170 \par
00171             leftVictor.set(ControlMode.PercentOutput, -1 * leftPIDValue);\par
00172             leftSparkMax.set(leftPIDValue);\par
00173             \par
00174             {\cf20 // System.out.println("Analog: " + leftAnalogY + ", Input: " + rightVel + ", Measured: " + rightAngVel + ", Normalized: " + normalRightAngVel + ", PID: " + rightPIDValue);}\par
00175             System.out.println({\cf22 "Right: "} + normalRightAngVel + {\cf22 ", Left: "} + normalLeftAngVel);\par
00176 \par
00177 \par
00178             rightTalon.set(ControlMode.PercentOutput, rightPIDValue);\par
00179             rightVictor.set(ControlMode.PercentOutput, rightPIDValue);\par
00180 \par
00181             \par
00182 \par
00183         \} {\cf19 else} {\cf19 if} (currentMode.equals(DEBUG_MODE)) \{\par
00184             {\cf19 switch} (debugEnabledMotor)\{\par
00185                 {\cf19 case} 0:\par
00186                     leftVictor.set(ControlMode.PercentOutput, -1 * leftVel);\par
00187                     {\cf19 break};\par
00188                 {\cf19 case} 1:\par
00189                     rightVictor.set(ControlMode.PercentOutput, rightVel);\par
00190                     {\cf19 break};\par
00191                 {\cf19 case} 2:\par
00192                     rightTalon.set(ControlMode.PercentOutput, rightVel);\par
00193                     {\cf19 break};\par
00194                 {\cf19 case} 3:\par
00195                     leftSparkMax.set(leftVel);\par
00196                     {\cf19 break};\par
00197             \}\par
00198         \} {\cf19 else} {\cf19 if} (currentMode.equals(STOP_MODE))\{\par
00199             {\cf20 // STOP!!!!! set motors to 0}\par
00200             {\cf20 // slower stop}\par
00201             slowingLeftVel = slowDown(slowingLeftVel);\par
00202             slowingRightVel = slowDown(slowingRightVel);\par
00203 \par
00204             leftVictor.set(ControlMode.PercentOutput, -1 *slowingLeftVel);\par
00205             leftSparkMax.set(slowingLeftVel);\par
00206             rightTalon.set(ControlMode.PercentOutput, slowingRightVel);\par
00207             rightVictor.set(ControlMode.PercentOutput, slowingRightVel);\par
00208 \par
00209         \}\par
00210         updatePosition();\par
00211         {\cf20 // System.out.println(rightTalon.getSelectedSensorVelocity()); // clicks per 100ms}\par
00212         {\cf20 // System.out.println(rightTalon.getSelectedSensorVelocity() * 10 * 60 / 4096);}\par
00213         {\cf20 // System.out.println(sparkMaxEncoder.getVelocity()); // actual rpm}\par
00214         {\cf20 // System.out.println("");}\par
00215 \par
00216 \par
00217 \par
00218 \par
00219         {\cf20 // // Print angular velocity and motor use level}\par
00220         {\cf20 // // get rotational speeds from the motors on each side}\par
00221         {\cf20 // // divide by 60 to get rotations per second}\par
00222         {\cf20 // double leftRPS = -1 * sparkMaxEncoder.getVelocity() / 60;}\par
00223 \par
00224         {\cf20 // if (Math.abs(leftRPS) > 0.1)\{}\par
00225         {\cf20 //  // // multiply by 10 because this is per 100ms - we want rps}\par
00226         {\cf20 //  double rightRPS = rightTalon.getSelectedSensorVelocity() * 10 / Constants.ENCODER_CPR;}\par
00227         {\cf20 //  System.out.println("Right Rps: " + rightRPS + "\\nLeft RPS: " + leftRPS);}\par
00228         {\cf20 //  System.out.println("Right velocity from controller: " + rightVel + "\\nLeft Velocity from controller: " + leftVel);}\par
00229         {\cf20 // \}}\par
00230          \par
00231 \par
00232     \}\par
}
{
\ql
References {\b frc.robot.Constants.ANALOG_DEAD_ZONE}, {\b frc.robot.subsystems.TankDrive.slowDown()}, {\b frc.robot.Constants.SPARK_MAX_CONVERSION_FACTOR}, {\b frc.robot.Constants.TALON_CONVERSION_FACTOR}, and {\b frc.robot.subsystems.TankDrive.updatePosition()}.}\par
}
{\xe \v getPosition\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:getPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.getPosition ()}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 287} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00288     \{\par
00289 \par
00290     \}\par
}
}
{\xe \v incrementPIDConstant\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:incrementPIDConstant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.incrementPIDConstant ()}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PID Tuning Mode: Increments the selected PID constant. }}\par
{
Definition at line {\b 363} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00363                                        \{\par
00364         {\cf19 if}(increasingPIDConstant) \{\par
00365             PIDConstants[currentPIDConstant] += PIDIncrements[currentPIDConstant];\par
00366         \} {\cf19 else} \{\par
00367             PIDConstants[currentPIDConstant] -= PIDIncrements[currentPIDConstant];\par
00368         \}\par
00369         {\cf20 // make sure constants are in [0, constantMax]}\par
00370         PIDConstants[currentPIDConstant] = Math.min(PIDConstants[currentPIDConstant], PIDMaximums[currentPIDConstant]);\par
00371         PIDConstants[currentPIDConstant] = Math.max(PIDConstants[currentPIDConstant], 0);\par
00372 \par
00373         {\cf20 // print PID constants}\par
00374         System.out.println({\cf22 "kP: "} + PIDConstants[0] + {\cf22 ", kI: "} + PIDConstants[1] + {\cf22 ", kD: "} + PIDConstants[2]);\par
00375 \par
00376         {\cf20 // set PID constant in the PID controllers}\par
00377         {\cf19 if}(currentPIDConstant == 0) \{\par
00378             leftPID.setP(PIDConstants[0]);\par
00379             rightPID.setP(PIDConstants[0]);\par
00380         \} {\cf19 else} {\cf19 if} (currentPIDConstant == 1) \{\par
00381             leftPID.setI(PIDConstants[1]);\par
00382             rightPID.setI(PIDConstants[1]);\par
00383         \} {\cf19 else} {\cf19 if} (currentPIDConstant == 2) \{\par
00384             leftPID.setD(PIDConstants[2]);\par
00385             rightPID.setD(PIDConstants[2]);\par
00386         \}\par
00387     \}\par
}
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.AButtonPressed()}.}\par
}
{\xe \v printPIDConstants\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:printPIDConstants}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.printPIDConstants ()}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 419} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00419                                     \{\par
00420         System.out.println({\cf22 "kP: "} + PIDConstants[0] + {\cf22 ", kI: "} + PIDConstants[1] + {\cf22 ", kD: "} + PIDConstants[2]);\par
00421     \}\par
}
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.YButtonPressed()}.}\par
}
{\xe \v printPosition\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:printPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.printPosition ()}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 433} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00434     \{\par
00435         Pose2d posFromWheelDisplacement = odometer.getPoseMeters();\par
00436         System.out.println({\cf22 "Position from odometer and wheel: "});\par
00437         System.out.println({\cf22 "X: "} + posFromWheelDisplacement.getX() + {\cf22 " Y: "} + posFromWheelDisplacement.getY() + {\cf22 " rotation: "} + posFromWheelDisplacement.getRotation());\par
00438 \par
00439         System.out.println({\cf22 "\\nPosition info from navx: "});\par
00440         System.out.println({\cf22 "X: "} + navx.getDisplacementX() + {\cf22 " Y: "} + navx.getDisplacementY() + {\cf22 " rotation: "} + navx.getAngle());\par
00441         System.out.println();\par
00442 \par
00443         {\cf20 // get the linear position of the left wheel and convert to meters}\par
00444         {\cf18 double} leftWheelPos = -1 * sparkMaxEncoder.getPosition() * 2 * Math.PI * Constants.TANK_WHEEL_RADIUS;\par
00445 \par
00446         {\cf20 // get the linear position of the right wheel and convert to meters}\par
00447         {\cf18 double} rightWheelPos = rightTalon.getSelectedSensorPosition() / Constants.ENCODER_CPR * 2 * Math.PI * Constants.TANK_WHEEL_RADIUS;\par
00448         System.out.println({\cf22 "Right Pos: "} + rightWheelPos + {\cf22 " left pos: "} + leftWheelPos);\par
00449 \par
00450 \par
00451         {\cf20 // Print angular velocity and motor use level}\par
00452         {\cf20 // get rotational speeds from the motors on each side}\par
00453         {\cf20 // divide by 60 to get rotations per second}\par
00454         {\cf18 double} leftRPS = -1 * sparkMaxEncoder.getVelocity() / 60;\par
00455         {\cf20 // // multiply by 10 because this is per 100ms - we want rps}\par
00456         {\cf18 double} rightRPS = rightTalon.getSelectedSensorVelocity() * 10 / Constants.ENCODER_CPR;\par
00457         System.out.println({\cf22 "Right Rps: "} + rightRPS + {\cf22 "\\nLeft RPS: "} + leftRPS);\par
00458 \par
00459     \}\par
}
{
\ql
References {\b frc.robot.Constants.ENCODER_CPR}, and {\b frc.robot.Constants.TANK_WHEEL_RADIUS}.}\par
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.AButtonPressed()}.}\par
}
{\xe \v resetPosition\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:resetPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.resetPosition ()}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 423} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00424     \{\par
00425         {\cf20 // reset the sensors to zero the position}\par
00426         navx.reset();\par
00427         navx.resetDisplacement();\par
00428         sparkMaxEncoder.setPosition(0);\par
00429         rightTalon.setSelectedSensorPosition(0);\par
00430         odometer.resetPosition({\cf17 new} Pose2d(), {\cf17 new} Rotation2d());\par
00431     \}\par
}
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.BButtonPressed()}, and {\b frc.robot.subsystems.TankDrive.TankDrive()}.}\par
}
{\xe \v slowDown\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:slowDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double frc.robot.subsystems.TankDrive.slowDown (double  {\i inputVelocity}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This will return a value lower than the input, and it is used to slow down the motors during stop mode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i inputVelocity} \cell }{between -1 and 1 (double) \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the new value (lower) \par
}}}{
Definition at line {\b 241} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00241                                                  \{\par
00242         {\cf20 // input is between -1 and 1}\par
00243         {\cf18 double} newVelocity;\par
00244         {\cf19 if} (Math.abs(inputVelocity) > Constants.SLOW_DOWN_CUTOFF)\{\par
00245             {\cf20 // velocity still needs to be reduced (magnatude is above cutoff)}\par
00246             newVelocity = inputVelocity / Constants.SLOW_DOWN_FACTOR;\par
00247         \} {\cf19 else} \{\par
00248             {\cf20 // input has reached cutoff, now returning 0 speed}\par
00249             {\cf19 return} 0;\par
00250         \}\par
00251         {\cf19 return} newVelocity;\par
00252     \}\par
}
{
\ql
References {\b frc.robot.Constants.SLOW_DOWN_CUTOFF}, and {\b frc.robot.Constants.SLOW_DOWN_FACTOR}.}\par
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.drive()}.}\par
}
{\xe \v toggleDecreasingPIDIncrement\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:toggleDecreasingPIDIncrement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.toggleDecreasingPIDIncrement ()}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 409} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00409                                                \{\par
00410         {\cf19 if}(increasingPIDConstant) \{\par
00411             increasingPIDConstant = {\cf17 false};\par
00412             System.out.println({\cf22 "Decreasing PID Constants"});\par
00413         \} {\cf19 else} \{\par
00414             increasingPIDConstant = {\cf17 true};\par
00415             System.out.println({\cf22 "Increasing PID Constants"});\par
00416         \}\par
00417     \}\par
}
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.XButtonPressed()}.}\par
}
{\xe \v turnOnStopMode\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:turnOnStopMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.turnOnStopMode ()}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
should be overridden for actual functionality because depends on drive base specifc speeds (for tank drive, there is a left and right speed, whereas for mecanum there are 4) }}\par
{
Reimplemented from {\b frc.robot.subsystems.DriveBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 255} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00255                                  \{\par
00256         {\cf19 if}(currentMode.equals(STOP_MODE)) {\cf19 return};\par
00257         currentMode = STOP_MODE;\par
00258         {\cf20 // Stop mode activated, so now the robot needs to slow down}\par
00259         {\cf20 // start by saving the last left and right velocities }\par
00260         slowingLeftVel = leftVel;\par
00261         slowingRightVel = rightVel;\par
00262         System.out.println({\cf22 "STOP MODE"});\par
00263     \}\par
}
}
{\xe \v updatePosition\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:updatePosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.updatePosition ()}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 292} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00293     \{\par
00294         {\cf20 // get the linear position of the left wheel and convert to meters}\par
00295         {\cf18 double} leftWheelPos = -1 * sparkMaxEncoder.getPosition() * 2 * Math.PI * Constants.TANK_WHEEL_RADIUS;\par
00296 \par
00297         {\cf20 // get the linear position of the right wheel and convert to meters}\par
00298         {\cf18 double} rightWheelPos = rightTalon.getSelectedSensorPosition() / Constants.ENCODER_CPR * 2 * Math.PI * Constants.TANK_WHEEL_RADIUS;\par
00299 \par
00300         {\cf20 // get the angle of the robot}\par
00301         {\cf18 double} theta = navx.getAngle() / 180 * Math.PI;\par
00302         Rotation2d rot = {\cf17 new} Rotation2d(theta);\par
00303         odometer.update(rot, leftWheelPos, rightWheelPos);\par
00304     \}\par
}
{
\ql
References {\b frc.robot.Constants.TANK_WHEEL_RADIUS}.}\par
{
\ql
Referenced by {\b frc.robot.subsystems.TankDrive.drive()}.}\par
}
{\xe \v updateRobotVelocity\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:updateRobotVelocity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.updateRobotVelocity ()}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 271} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00271                                       \{\par
00272         \par
00273         {\cf20 // get rotational speeds from the motors on each side}\par
00274         {\cf20 // divide by 60 to get rotations per second}\par
00275         {\cf20 // double leftRPS = -1 * sparkMaxEncoder.getVelocity() / 60;}\par
00276         {\cf20 // // multiply by 10 because this is per 100ms - we want rps}\par
00277         {\cf20 // double rightRPS = rightTalon.getSelectedSensorVelocity() * 10 / Constants.ENCODER_CPR;}\par
00278 \par
00279         {\cf20 // // find linear velocities in m/s}\par
00280         {\cf20 // double leftVel = (leftRPS * 2 * Math.PI) * Constants.TANK_WHEEL_RADIUS;}\par
00281         {\cf20 // double rightVel = (rightRPS * 2 * Math.PI) * Constants.TANK_WHEEL_RADIUS;}\par
00282 \par
00283         {\cf20 // currentSpeeds.leftMetersPerSecond = leftVel;}\par
00284         {\cf20 // currentSpeeds.rightMetersPerSecond = rightVel;}\par
00285     \}\par
}
}
{\xe \v XButtonPressed\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:XButtonPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.XButtonPressed ()}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b frc.robot.subsystems.DriveBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 343} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00343                                  \{\par
00344         {\cf19 switch}(currentMode) \{\par
00345             {\cf19 case} PID_TUNING_MODE:\par
00346                 toggleDecreasingPIDIncrement();\par
00347                 {\cf19 break};\par
00348         \}\par
00349     \}\par
}
{
\ql
References {\b frc.robot.subsystems.TankDrive.toggleDecreasingPIDIncrement()}.}\par
}
{\xe \v YButtonPressed\:frc.robot.subsystems.TankDrive}
{\xe \v frc.robot.subsystems.TankDrive\:YButtonPressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frc.robot.subsystems.TankDrive.YButtonPressed ()}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b frc.robot.subsystems.DriveBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAADJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 352} of file {\b TankDrive.java}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00352                                  \{\par
00353         {\cf19 switch}(currentMode) \{\par
00354             {\cf19 case} PID_TUNING_MODE:\par
00355                 printPIDConstants();\par
00356                 {\cf19 break};\par
00357         \}\par
00358     \}\par
}
{
\ql
References {\b frc.robot.subsystems.TankDrive.printPIDConstants()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
robotics/2023DriveBase/src/main/java/frc/robot/subsystems/{\b TankDrive.java}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
robotics/2023DriveBase/Readme.md File Reference\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/Readme.md}
{\xe \v robotics/2023DriveBase/Readme.md}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
robotics/2023DriveBase/src/main/java/frc/robot/Constants.java File Reference\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/src/main/java/frc/robot/Constants.java}
{\xe \v robotics/2023DriveBase/src/main/java/frc/robot/Constants.java}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b frc.robot.Constants}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constants - set once, and use throught the code Naming convention is all caps, spaces are underscores LIKE_THIS. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Packages\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
package {\b frc.robot}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Constants.java\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/src/main/java/frc/robot/Constants.java}
{\xe \v robotics/2023DriveBase/src/main/java/frc/robot/Constants.java}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 package }frc.robot;\par
00002 \par
00003 {\cf17 import} java.lang.Math;\par
00004 {\cf20 }\par
00005 {\cf20 /**}\par
00006 {\cf20  * Constants - set once, and use throught the code}\par
00007 {\cf20  * Naming convention is all caps, spaces are underscores LIKE_THIS}\par
00008 {\cf20  */}\par
00009 {\cf17 public} {\cf17 class }Constants \{\par
00010 \par
00011     {\cf20 // the port for the xbox controller}\par
00012     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 int} XBOX_CONTROLLER_PORT            = 0; \par
00013 \par
00014     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 double} DRIVE_MAX_ANGULAR_VELOCITY   = 2 * Math.PI;\par
00015     \par
00016     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 double} TANK_WHEEL_RADIUS            = 0.075; {\cf20 // meters}\par
00017 \par
00018     {\cf17 public} {\cf17 static} {\cf18 double} maxVelocity;\par
00019 \par
00020     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 int} ENCODER_CPR = 4096;\par
00021 \par
00022     {\cf20 // the amount of time (in seconds) between calls of the periodic function}\par
00023     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 double} dt = 0.02;\par
00024 \par
00025     {\cf20 // for tank drive}\par
00026     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 int} LEFT_VICTOR_ID = 7;\par
00027     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 int} RIGHT_VICTOR_ID = 4;\par
00028     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 int} TALON_ID = 9;\par
00029     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 int} SPARK_MAX_ID = 12;\par
00030     \par
00031     {\cf20 // for mecanum drive FR = front right, FL = front left, RR = rear right, RL = rear left}\par
00032     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 int} FR_TALON_PORT = 2;\par
00033     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 int} FL_TALON_PORT = 8;\par
00034     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 int} RR_TALON_PORT = 10;\par
00035     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 int} RL_TALON_PORT = 4;\par
00036 \par
00037     {\cf20 // for converting motor encoder readings to standard units (rad/s)}\par
00038     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 double} SPARK_MAX_CONVERSION_FACTOR = (2 * Math.PI) / 60; {\cf20 // base units are RPM}\par
00039     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 double} TALON_CONVERSION_FACTOR = 10 * 2 * Math.PI / ENCODER_CPR; {\cf20 // base units are clicks per 100ms}\par
00040     \par
00041     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 double} ANALOG_DEAD_ZONE = 0.1;\par
00042 \par
00043     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 double} ROBOT_WIDTH = 0.40;\par
00044     {\cf20 // for slowing down (stop mode)}\par
00045     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 double} SLOW_DOWN_CUTOFF = 0.05;\par
00046     {\cf17 public} {\cf17 static} {\cf17 final} {\cf18 double} SLOW_DOWN_FACTOR = 2; {\cf20 // when slowing down, the }\par
00047     {\cf20 //previous speed is divided by this factor (higher = slow down faster)}\par
00048 \par
00049     Constants() \{\par
00050         \par
00051     \}\par
00052 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
robotics/2023DriveBase/src/main/java/frc/robot/Main.java File Reference\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/src/main/java/frc/robot/Main.java}
{\xe \v robotics/2023DriveBase/src/main/java/frc/robot/Main.java}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b frc.robot.Main}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Do NOT add any static variables to this class, or any initialization at all. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Packages\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
package {\b frc.robot}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Main.java\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/src/main/java/frc/robot/Main.java}
{\xe \v robotics/2023DriveBase/src/main/java/frc/robot/Main.java}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright (c) FIRST and other WPILib contributors.}\par
00002 {\cf20 // Open Source Software; you can modify and/or share it under the terms of}\par
00003 {\cf20 // the WPILib BSD license file in the root directory of this project.}\par
00004 \par
00005 {\cf17 package }frc.robot;\par
00006 \par
00007 {\cf17 import} edu.wpi.first.wpilibj.RobotBase;\par
00008 {\cf20 }\par
00009 {\cf20 /**}\par
00010 {\cf20  * Do NOT add any static variables to this class, or any initialization at all. Unless you know what}\par
00011 {\cf20  * you are doing, do not modify this file except to change the parameter class to the startRobot}\par
00012 {\cf20  * call.}\par
00013 {\cf20  */}\par
00014 {\cf17 public} {\cf17 final} {\cf17 class }Main \{\par
00015   {\cf17 private} Main() \{\}\par
00016 {\cf20 }\par
00017 {\cf20   /**}\par
00018 {\cf20    * Main initialization function. Do not perform any initialization here.}\par
00019 {\cf20    *}\par
00020 {\cf20    * <p>If you change your main robot class, change the parameter type.}\par
00021 {\cf20    */}\par
00022   {\cf17 public} {\cf17 static} {\cf18 void} main(String... args) \{\par
00023     RobotBase.startRobot(Robot::new);\par
00024   \}\par
00025 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
robotics/2023DriveBase/src/main/java/frc/robot/Robot.java File Reference\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/src/main/java/frc/robot/Robot.java}
{\xe \v robotics/2023DriveBase/src/main/java/frc/robot/Robot.java}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b frc.robot.Robot}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The VM is configured to automatically run this class, and to call the functions corresponding to each mode, as described in the TimedRobot documentation. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Packages\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
package {\b frc.robot}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Robot.java\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/src/main/java/frc/robot/Robot.java}
{\xe \v robotics/2023DriveBase/src/main/java/frc/robot/Robot.java}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright (c) FIRST and other WPILib contributors.}\par
00002 {\cf20 // Open Source Software; you can modify and/or share it under the terms of}\par
00003 {\cf20 // the WPILib BSD license file in the root directory of this project.}\par
00004 \par
00005 {\cf17 package }frc.robot;\par
00006 \par
00007 {\cf17 import} edu.wpi.first.wpilibj.TimedRobot;\par
00008 {\cf17 import} edu.wpi.first.wpilibj.XboxController;\par
00009 {\cf17 import} edu.wpi.first.wpilibj.smartdashboard.SendableChooser;\par
00010 {\cf17 import} edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;\par
00011 {\cf17 import} edu.wpi.first.cameraserver.CameraServer;\par
00012 {\cf17 import} frc.robot.subsystems.*;\par
00013 {\cf20 }\par
00014 {\cf20 /**}\par
00015 {\cf20  * The VM is configured to automatically run this class, and to call the functions corresponding to}\par
00016 {\cf20  * each mode, as described in the TimedRobot documentation. If you change the name of this class or}\par
00017 {\cf20  * the package after creating this project, you must also update the build.gradle file in the}\par
00018 {\cf20  * project.}\par
00019 {\cf20  */}\par
00020 {\cf17 public} {\cf17 class }Robot {\cf17 extends} TimedRobot \{\par
00021 \par
00022   \par
00023   {\cf17 private} {\cf17 static} {\cf17 final} String kDefaultAuto = {\cf22 "Default"};\par
00024   {\cf17 private} {\cf17 static} {\cf17 final} String kCustomAuto = {\cf22 "My Auto"};\par
00025   {\cf17 private} String m_autoSelected;\par
00026   {\cf17 private} {\cf17 final} SendableChooser<String> m_chooser = {\cf17 new} SendableChooser<>();\par
00027 \par
00028   {\cf17 private} XboxController xboxController = {\cf17 new} XboxController(Constants.XBOX_CONTROLLER_PORT);\par
00029   {\cf17 private} DriveBase driveBase;\par
00030 {\cf20 }\par
00031 {\cf20   /**}\par
00032 {\cf20    * This function is run when the robot is first started up and should be used for any}\par
00033 {\cf20    * initialization code.}\par
00034 {\cf20    */}\par
00035   @Override\par
00036   {\cf17 public} {\cf18 void} robotInit() \{\par
00037     m_chooser.setDefaultOption({\cf22 "Default Auto"}, kDefaultAuto);\par
00038     m_chooser.addOption({\cf22 "My Auto"}, kCustomAuto);\par
00039     SmartDashboard.putData({\cf22 "Auto choices"}, m_chooser);\par
00040     CameraServer.startAutomaticCapture(0);\par
00041     CameraServer.startAutomaticCapture(1);\par
00042 \par
00043 \par
00044     {\cf20 // tank drive initialization}\par
00045     {\cf20 // driveBase = createTankDrive();    }\par
00046     {\cf20 // mecanum drive initialization}\par
00047     driveBase = createMecanumDrive();\par
00048     \par
00049     {\cf20 // // set the dead zone for the controller analog sticks}\par
00050     {\cf20 // driveBase.setDeadband(Constants.ANALOG_DEAD_ZONE);}\par
00051   \}\par
00052 {\cf20 }\par
00053 {\cf20   /**}\par
00054 {\cf20    * This function is called every robot packet, no matter the mode. Use this for items like}\par
00055 {\cf20    * diagnostics that you want ran during disabled, autonomous, teleoperated and test.}\par
00056 {\cf20    *}\par
00057 {\cf20    * <p>This runs after the mode specific periodic functions, but before LiveWindow and}\par
00058 {\cf20    * SmartDashboard integrated updating.}\par
00059 {\cf20    */}\par
00060   @Override\par
00061   {\cf17 public} {\cf18 void} robotPeriodic() \{\}\par
00062 {\cf20 }\par
00063 {\cf20   /**}\par
00064 {\cf20    * This autonomous (along with the chooser code above) shows how to select between different}\par
00065 {\cf20    * autonomous modes using the dashboard. The sendable chooser code works with the Java}\par
00066 {\cf20    * SmartDashboard. If you prefer the LabVIEW Dashboard, remove all of the chooser code and}\par
00067 {\cf20    * uncomment the getString line to get the auto name from the text box below the Gyro}\par
00068 {\cf20    *}\par
00069 {\cf20    * <p>You can add additional auto modes by adding additional comparisons to the switch structure}\par
00070 {\cf20    * below with additional strings. If using the SendableChooser make sure to add them to the}\par
00071 {\cf20    * chooser code above as well.}\par
00072 {\cf20    */}\par
00073   @Override\par
00074   {\cf17 public} {\cf18 void} autonomousInit() \{\par
00075     m_autoSelected = m_chooser.getSelected();\par
00076     {\cf20 // m_autoSelected = SmartDashboard.getString("Auto Selector", kDefaultAuto);}\par
00077     System.out.println({\cf22 "Auto selected: "} + m_autoSelected);\par
00078   \}\par
00079 {\cf20 }\par
00080 {\cf20   /** This function is called periodically during autonomous. */}\par
00081   @Override\par
00082   {\cf17 public} {\cf18 void} autonomousPeriodic() \{\par
00083     {\cf19 switch} (m_autoSelected) \{\par
00084       {\cf19 case} kCustomAuto:\par
00085         {\cf20 // Put custom auto code here}\par
00086         {\cf19 break};\par
00087       {\cf19 case} kDefaultAuto:\par
00088       {\cf19 default}:\par
00089         {\cf20 // Put default auto code here}\par
00090         {\cf19 break};\par
00091     \}\par
00092   \}\par
00093 {\cf20 }\par
00094 {\cf20   /** This function is called once when teleop is enabled. */}\par
00095   @Override\par
00096   {\cf17 public} {\cf18 void} teleopInit() \{\}\par
00097 {\cf20 }\par
00098 {\cf20   /** This function is called periodically during operator control. */}\par
00099   @Override\par
00100   {\cf17 public} {\cf18 void} teleopPeriodic() \{\par
00101     {\cf20 // TODO: put the driving loop here}\par
00102     {\cf20 // TODO: check if buttons are pressed and comment controller mapping}\par
00103     {\cf19 if} (xboxController.getRightBumperPressed()) driveBase.increaseSpeedBracket();\par
00104     {\cf19 if} (xboxController.getLeftBumperPressed()) driveBase.decreaseSpeedBracket();\par
00105 \par
00106     {\cf20 // switch between modes (for DPad, 0 is up, and angles go clockwise, so 90 is right)}\par
00107     {\cf20 // up}\par
00108     {\cf19 if} (xboxController.getPOV() == 0) driveBase.turnOnDefaultMode();\par
00109     {\cf20 // right}\par
00110     {\cf19 if} (xboxController.getPOV() == 90) driveBase.turnOnStopMode();\par
00111     {\cf20 // left}\par
00112     {\cf19 if} (xboxController.getPOV() == 270) driveBase.turnOnDebugMode();\par
00113     {\cf20 // down}\par
00114     {\cf19 if} (xboxController.getPOV() == 180) driveBase.turnONPIDTuningMode();\par
00115 \par
00116 \par
00117     {\cf20 // Debug controls}\par
00118     {\cf19 if} (xboxController.getRightStickButtonPressed()) driveBase.cycleMotorDebugMode();\par
00119 \par
00120     {\cf20 // actions of the four button presses}\par
00121     {\cf19 if} (xboxController.getAButtonPressed()) \{\par
00122       driveBase.AButtonPressed();\par
00123     \}\par
00124     {\cf19 if} (xboxController.getBButtonPressed()) \{\par
00125       driveBase.BButtonPressed();\par
00126     \}\par
00127     {\cf19 if} (xboxController.getXButtonPressed()) \{\par
00128       driveBase.XButtonPressed();\par
00129     \}\par
00130     {\cf19 if} (xboxController.getYButtonPressed()) \{\par
00131       driveBase.YButtonPressed();\par
00132     \}\par
00133 \par
00134     {\cf20 // get analog input from xbox controller}\par
00135     {\cf18 double} leftAnalogX  = xboxController.getLeftX();\par
00136     {\cf18 double} leftAnalogY  = xboxController.getLeftY();\par
00137     {\cf18 double} rightAnalogX = xboxController.getRightX();\par
00138     {\cf18 double} rightAnalogY = xboxController.getRightY();\par
00139 \par
00140     {\cf20 // process input (determine wheelspeeds)}\par
00141     driveBase.drive(leftAnalogX, leftAnalogY, rightAnalogX, rightAnalogY);\par
00142   \}\par
00143 {\cf20 }\par
00144 {\cf20   /** This function is called once when the robot is disabled. */}\par
00145   @Override\par
00146   {\cf17 public} {\cf18 void} disabledInit() \{\}{\cf20 }\par
00147 {\cf20   /** This function is called periodically when disabled. */}\par
00148   @Override\par
00149   {\cf17 public} {\cf18 void} disabledPeriodic() \{\}\par
00150 {\cf20 }\par
00151 {\cf20   /** This function is called once when test mode is enabled. */}\par
00152   @Override\par
00153   {\cf17 public} {\cf18 void} testInit() \{\}\par
00154 {\cf20 }\par
00155 {\cf20   /** This function is called periodically during test mode. */}\par
00156   @Override\par
00157   {\cf17 public} {\cf18 void} testPeriodic() \{\}\par
00158 \par
00159 \par
00160   {\cf17 private} TankDrive createTankDrive() \{\par
00161     {\cf19 return} {\cf17 new} TankDrive(Constants.SPARK_MAX_ID, Constants.LEFT_VICTOR_ID,\par
00162                          Constants.TALON_ID, Constants.RIGHT_VICTOR_ID);\par
00163   \}\par
00164 \par
00165   {\cf17 private} MecaDrive createMecanumDrive() \{\par
00166     {\cf19 return} {\cf17 new} MecaDrive(Constants.FL_TALON_PORT, Constants.FR_TALON_PORT,\par
00167                          Constants.RL_TALON_PORT, Constants.RR_TALON_PORT);\par
00168   \}\par
00169 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
robotics/2023DriveBase/src/main/java/frc/robot/subsystems/DriveBase.java File Reference\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/src/main/java/frc/robot/subsystems/DriveBase.java}
{\xe \v robotics/2023DriveBase/src/main/java/frc/robot/subsystems/DriveBase.java}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b frc.robot.subsystems.DriveBase}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Packages\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
package {\b frc.robot.subsystems}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DriveBase.java\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/src/main/java/frc/robot/subsystems/DriveBase.java}
{\xe \v robotics/2023DriveBase/src/main/java/frc/robot/subsystems/DriveBase.java}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 package }frc.robot.subsystems;\par
00002 {\cf17 import} java.lang.Math;\par
00003 \par
00004 {\cf17 public} {\cf17 abstract} {\cf17 class }DriveBase \{\par
00005     {\cf20 // used to scale speeds - 1 would be max speed, 0.5 would be half speed, etc.}\par
00006     {\cf18 double} speedMultiplier = 0.6;\par
00007 \par
00008     {\cf20 // different modes}\par
00009     String currentMode;\par
00010     {\cf17 static} {\cf17 final} String DEFAULT_MODE = {\cf22 "DEFAULT"}; {\cf20 // regular driving}\par
00011     {\cf17 static} {\cf17 final} String DEBUG_MODE = {\cf22 "DEBUG"}; {\cf20 // spin only one motor at a time}\par
00012     {\cf17 static} {\cf17 final} String PID_TUNING_MODE = {\cf22 "PIDTUNING"}; {\cf20 // tune PID constants}\par
00013     {\cf17 static} {\cf17 final} String STOP_MODE = {\cf22 "STOP"}; {\cf20 // stop the robot}\par
00014 \par
00015     {\cf20 // the motor to be activated during debug mode}\par
00016     {\cf18 int} debugEnabledMotor = 0;\par
00017 {\cf20 }\par
00018 {\cf20     /**}\par
00019 {\cf20      * Drive the robot with controller input}\par
00020 {\cf20      * }\par
00021 {\cf20      * These are doubles on the interval [-1, 1] and come from the controller's}\par
00022 {\cf20      * analog sticks}\par
00023 {\cf20      * }\par
00024 {\cf20      */}\par
00025     {\cf17 public} {\cf17 abstract} {\cf18 void} drive({\cf18 double} leftAnalogX, {\cf18 double} leftAnalogY,\par
00026                       {\cf18 double} rightAnalogX, {\cf18 double} rightAnalogY);\par
00027     {\cf20 }\par
00028 {\cf20     /**}\par
00029 {\cf20      * The speed bracket controls the multiplire for al the speeds}\par
00030 {\cf20      * So when you change it, lets say, to 1/2 speed, all movement will be at}\par
00031 {\cf20      * 1/2 speed}\par
00032 {\cf20      */}\par
00033     {\cf17 public} {\cf18 void} increaseSpeedBracket() \{\par
00034         speedMultiplier = Math.min(1, speedMultiplier + 0.1);\par
00035     \}\par
00036 \par
00037     {\cf17 public} {\cf18 void} decreaseSpeedBracket() \{\par
00038         {\cf20 // the min is 0.2 because below that the robot is unlikely to move}\par
00039         speedMultiplier = Math.max(0.2, speedMultiplier - 0.1);\par
00040     \}\par
00041 \par
00042     {\cf17 public} {\cf18 void} turnOnDefaultMode() \{\par
00043         {\cf19 if}(currentMode.equals(DEFAULT_MODE)) {\cf19 return};\par
00044         currentMode = DEFAULT_MODE;\par
00045         System.out.println({\cf22 "DEFAULT MODE"});\par
00046     \}\par
00047 \par
00048     {\cf17 public} {\cf18 void} turnOnDebugMode() \{\par
00049         {\cf19 if}(currentMode.equals(DEBUG_MODE)) {\cf19 return};\par
00050         currentMode = DEBUG_MODE;\par
00051         System.out.println({\cf22 "DEBUG MODE"});\par
00052     \}\par
00053 {\cf20 }\par
00054 {\cf20     /**}\par
00055 {\cf20      * should be overridden for actual functionality because depends on}\par
00056 {\cf20      * drive base specifc speeds (for tank drive, there is a left and right}\par
00057 {\cf20      * speed, whereas for mecanum there are 4)}\par
00058 {\cf20      */}\par
00059     {\cf17 public} {\cf18 void} turnOnStopMode() \{\par
00060         {\cf19 if}(currentMode.equals(STOP_MODE)) {\cf19 return};\par
00061         currentMode = STOP_MODE;\par
00062         System.out.println({\cf22 "STOP MODE"});\par
00063     \}\par
00064 \par
00065     {\cf17 public} {\cf18 void} turnONPIDTuningMode() \{\par
00066         {\cf19 if}(currentMode.equals(PID_TUNING_MODE)) {\cf19 return};\par
00067         currentMode = PID_TUNING_MODE;\par
00068         System.out.println({\cf22 "PID TUNING MODE"});\par
00069     \}\par
00070 {\cf20 }\par
00071 {\cf20     /**}\par
00072 {\cf20      * Again needs to be implemented in sub classes becuase there might}\par
00073 {\cf20      * be different numbers of motors}\par
00074 {\cf20      */}\par
00075     {\cf17 public} {\cf17 abstract} {\cf18 void} cycleMotorDebugMode();\par
00076     \par
00077     {\cf20 // the following methods can be overridden for real functionality}\par
00078     {\cf17 public} {\cf18 void} AButtonPressed() \{\}\par
00079 \par
00080     {\cf17 public} {\cf18 void} BButtonPressed() \{\}\par
00081 \par
00082     {\cf17 public} {\cf18 void} XButtonPressed() \{\}\par
00083 \par
00084     {\cf17 public} {\cf18 void} YButtonPressed() \{\}\par
00085 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
robotics/2023DriveBase/src/main/java/frc/robot/subsystems/MecaDrive.java File Reference\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/src/main/java/frc/robot/subsystems/MecaDrive.java}
{\xe \v robotics/2023DriveBase/src/main/java/frc/robot/subsystems/MecaDrive.java}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b frc.robot.subsystems.MecaDrive}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Packages\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
package {\b frc.robot.subsystems}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MecaDrive.java\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/src/main/java/frc/robot/subsystems/MecaDrive.java}
{\xe \v robotics/2023DriveBase/src/main/java/frc/robot/subsystems/MecaDrive.java}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 package }frc.robot.subsystems;\par
00002 \par
00003 {\cf17 import} com.ctre.phoenix.motorcontrol.ControlMode;\par
00004 {\cf17 import} com.ctre.phoenix.motorcontrol.can.TalonSRX;\par
00005 \par
00006 {\cf17 import} frc.robot.Constants;\par
00007 \par
00008 {\cf17 import} java.lang.Math;\par
00009 \par
00010 {\cf17 public} {\cf17 class }MecaDrive {\cf17 extends} DriveBase \{\par
00011     {\cf20 // scaling down vertical speed because its faster than other speeds}\par
00012     {\cf17 final} {\cf18 double} verticalSpeedMultiplier = 0.8;\par
00013 \par
00014     {\cf20 // scaling up horinzontal speed because its slower than the other speeds}\par
00015     {\cf17 final} {\cf18 double} horizontalSPeedMultiplier = 2.5;\par
00016 \par
00017     TalonSRX frontLeftMotor, frontRightMotor, rearLeftMotor, rearRightMotor;\par
00018 \par
00019     {\cf20 // Stop mode variables}\par
00020 \par
00021     {\cf20 // to save the last velocities so the robot can slow down}\par
00022     {\cf18 double}[] slowingDownSpeeds = {\cf17 new} {\cf18 double}[4];\par
00023 \par
00024     {\cf20 // this makes the left and right vel scope include the function that sets}\par
00025     {\cf20 // the slowing values so the function can use them}\par
00026     {\cf18 double}[] combinedSpeeds = {\cf17 new} {\cf18 double}[4];\par
00027 {\cf20 }\par
00028 {\cf20     /**}\par
00029 {\cf20      * Constructor for Mecanum Drive Class}\par
00030 {\cf20      * }\par
00031 {\cf20      * @param frontLeftMotorPort}\par
00032 {\cf20      * @param rearLeftMotorPort}\par
00033 {\cf20      * @param frontRightMotorPort}\par
00034 {\cf20      * @param rearRightMotorPort}\par
00035 {\cf20      */}\par
00036     {\cf17 public} MecaDrive({\cf18 int} frontLeftMotorPort, {\cf18 int} frontRightMotorPort,\par
00037                      {\cf18 int} rearLeftMotorPort, {\cf18 int} rearRightMotorPort) \{\par
00038         frontLeftMotor = {\cf17 new} TalonSRX(frontLeftMotorPort);\par
00039         frontRightMotor = {\cf17 new} TalonSRX(frontRightMotorPort);\par
00040         rearLeftMotor = {\cf17 new} TalonSRX(rearLeftMotorPort);\par
00041         rearRightMotor = {\cf17 new} TalonSRX(rearRightMotorPort);\par
00042     \} \par
00043 {\cf20 }\par
00044 {\cf20     /**}\par
00045 {\cf20      * drive the robot using controller inputs}\par
00046 {\cf20      * }\par
00047 {\cf20      * Left analog stick controls translation}\par
00048 {\cf20      * Right analog stick controls rotation (move it right -> rotate clockwise, move it left -> rotate counterclockwise)}\par
00049 {\cf20      * }\par
00050 {\cf20      * positive is right/up}\par
00051 {\cf20      * }\par
00052 {\cf20      * @param leftAnalogX the x position of the left analog stick; range: [-1, 1]}\par
00053 {\cf20      * @param leftAnalogY the y position of the left analog stick; range: [-1, 1]}\par
00054 {\cf20      * @param rightAnalogX the x position of the right analog stick; range: [-1, 1]}\par
00055 {\cf20      * @param rightAnalogY the y position of the right analog stick; range: [-1, 1]}\par
00056 {\cf20      * }\par
00057 {\cf20      * Debug mode:}\par
00058 {\cf20      * }\par
00059 {\cf20      *  When you press the left stick down (left stick button) the robot enters}\par
00060 {\cf20      * debug mode (bool debugMode), and the robot will only move power one wheel}\par
00061 {\cf20      * at a time. Toggle through these wheels by pressing the left stick button }\par
00062 {\cf20      * more (FL -> FR -> BL -> BR) then, after BR, it will leave debug mode and }\par
00063 {\cf20      * go back into all wheel drive}\par
00064 {\cf20      * }\par
00065 {\cf20      */}\par
00066     {\cf17 public} {\cf18 void} drive({\cf18 double} leftAnalogX, {\cf18 double} leftAnalogY,\par
00067                       {\cf18 double} rightAnalogX, {\cf18 double} rightAnalogY) \{\par
00068         \par
00069         {\cf20 // left analog stick controls translation}\par
00070         {\cf20 // right analog stick controls rotation}\par
00071         \par
00072 {\cf20 }\par
00073 {\cf20          /**}\par
00074 {\cf20          * Add deadzone (stop all movement when input is under a certain amount)}\par
00075 {\cf20          * Compare joystick distance from normal position (0)}\par
00076 {\cf20          */}\par
00077         \par
00078         {\cf20 // Left analog joystick distance from origin from pythagoreas }\par
00079         {\cf18 double} leftJoystickDistance = Math.sqrt(Math.pow(leftAnalogX, 2) +\par
00080                                                 Math.pow(leftAnalogY, 2));\par
00081         {\cf19 if} (leftJoystickDistance < Constants.ANALOG_DEAD_ZONE) \{\par
00082             {\cf20 // joystick is within the deadzone, so set to 0}\par
00083             leftAnalogX = 0;\par
00084             leftAnalogY = 0;\par
00085         \}\par
00086         {\cf19 if} (rightAnalogX < Constants.ANALOG_DEAD_ZONE)\{\par
00087             rightAnalogX = 0;\par
00088         \}                   \par
00089 \par
00090         combinedSpeeds = combineSpeeds(leftAnalogX,  leftAnalogY, \par
00091                                        rightAnalogX, rightAnalogY);\par
00092 \par
00093         {\cf19 switch} (currentMode)\{\par
00094             {\cf19 case} DEFAULT_MODE:\par
00095                  {\cf20 // set the motor speeds (normal)}\par
00096                 frontLeftMotor.set(ControlMode.PercentOutput, combinedSpeeds[0] * -1);\par
00097                 frontRightMotor.set(ControlMode.PercentOutput, combinedSpeeds[1]);\par
00098                 rearLeftMotor.set(ControlMode.PercentOutput, combinedSpeeds[2] * -1);\par
00099                 rearRightMotor.set(ControlMode.PercentOutput, combinedSpeeds[3]);\par
00100                 {\cf19 break};\par
00101             {\cf19 case} STOP_MODE:\par
00102                 {\cf20 // STOP!!!!! set motors to 0}\par
00103                 {\cf20 // slower stop}\par
00104                 slowingDownSpeeds = slowDown(slowingDownSpeeds);\par
00105 \par
00106                 frontLeftMotor.set(ControlMode.PercentOutput, slowingDownSpeeds[0] * -1);\par
00107                 frontRightMotor.set(ControlMode.PercentOutput, slowingDownSpeeds[1]);\par
00108                 rearLeftMotor.set(ControlMode.PercentOutput, slowingDownSpeeds[2] * -1);\par
00109                 rearRightMotor.set(ControlMode.PercentOutput, slowingDownSpeeds[3]);\par
00110                 {\cf19 break};\par
00111             {\cf19 case} DEBUG_MODE:\par
00112                 {\cf20 // Debug mode (toggle wheels with left stick button)}\par
00113                 \par
00114                 {\cf19 switch} (debugEnabledMotor)\{\par
00115                     {\cf19 case} 0:\par
00116                         frontLeftMotor.set(ControlMode.PercentOutput, combinedSpeeds[0] * -1);\par
00117                         {\cf19 break};\par
00118                     {\cf19 case} 1:\par
00119                         frontRightMotor.set(ControlMode.PercentOutput, combinedSpeeds[1]);\par
00120                         {\cf19 break};\par
00121                     {\cf19 case} 2:\par
00122                         rearLeftMotor.set(ControlMode.PercentOutput, combinedSpeeds[2] * -1);\par
00123                         {\cf19 break};\par
00124                     {\cf19 case} 3:\par
00125                         rearRightMotor.set(ControlMode.PercentOutput, combinedSpeeds[3]);\par
00126                         {\cf19 break};  \par
00127                 \}\par
00128 \par
00129                 {\cf19 break};\par
00130             {\cf19 case} PID_TUNING_MODE:\par
00131                 {\cf20 // nothing yet}\par
00132                 {\cf19 break};\par
00133         \}\par
00134     \}\par
00135 \par
00136 {\cf20 }\par
00137 {\cf20     /**}\par
00138 {\cf20      * }\par
00139 {\cf20      * Process the controller input into speeds for mecanum wheels}\par
00140 {\cf20      * }\par
00141 {\cf20      * @param leftAnalogX}\par
00142 {\cf20      * @param leftAnalogY}\par
00143 {\cf20      * @param rightAnalogX}\par
00144 {\cf20      * @param rightAnalogY}\par
00145 {\cf20      * @return array of all processed speeds \{front left, front right, back left, back right\}}\par
00146 {\cf20      */}\par
00147     {\cf17 private} {\cf18 double}[] combineSpeeds({\cf18 double} leftAnalogX,  {\cf18 double} leftAnalogY,\par
00148                                    {\cf18 double} rightAnalogX, {\cf18 double} rightAnalogY)\{\par
00149 \par
00150         leftAnalogY *= verticalSpeedMultiplier;\par
00151         leftAnalogX *= horizontalSPeedMultiplier;\par
00152        \par
00153         {\cf20 // arrays for wheel speeds (percents)}\par
00154         {\cf20 // 1st is front left, 2nd is front right, 3rd is back left, 4th is back right}\par
00155         {\cf18 double}[] verticalSpeeds = \{leftAnalogY, leftAnalogY,\par
00156                                    leftAnalogY, leftAnalogY\};\par
00157         \par
00158         {\cf20 // negatives due to wheels going in opposite directions during left or right translation}\par
00159         {\cf18 double}[] horizontalSpeeds = \{-1 * leftAnalogX, leftAnalogX,\par
00160                                      leftAnalogX, -1 * leftAnalogX\};\par
00161 \par
00162         {\cf20 // left and right wheels should go different directions to rotate the robot}\par
00163         {\cf18 double}[] rotationSpeeds = \{-1 * rightAnalogX, rightAnalogX,\par
00164                                    -1 * rightAnalogX, rightAnalogX\};\par
00165         \par
00166         {\cf20 // so these could exceed 1 (not good; we cannot run the motors at over 100%)}\par
00167         {\cf20 // we will use the maximum speed to scale all the other speeds to something below 1}\par
00168         {\cf19 for} ({\cf18 int} i = 0; i < 4; i ++)\par
00169             combinedSpeeds[i] = verticalSpeeds[i] + horizontalSpeeds[i] + rotationSpeeds[i];\par
00170 \par
00171         {\cf20 // find the max of the above speeds so we can check if it is above 1}\par
00172         {\cf18 double} maxSpeed = Integer.MIN_VALUE;\par
00173 \par
00174         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\par
00175             {\cf19 if} (Math.abs(combinedSpeeds[i]) > maxSpeed) maxSpeed = Math.abs(combinedSpeeds[i]);\par
00176         \par
00177         maxSpeed = Math.max(1, maxSpeed); {\cf20 // if it is under 1, we can basically ignore it    }\par
00178 \par
00179         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++) \{\par
00180             {\cf20 // scale the speeds}\par
00181             combinedSpeeds[i] = (1 / maxSpeed) * combinedSpeeds[i];\par
00182 \par
00183             {\cf20 // we also need to scale the speeds by the speed multiplier}\par
00184             combinedSpeeds[i] = combinedSpeeds[i] * speedMultiplier;\par
00185         \}\par
00186 \par
00187         {\cf19 return} combinedSpeeds;\par
00188     \}\par
00189 {\cf20 }\par
00190 {\cf20     /**}\par
00191 {\cf20      * This will return a value lower than the input, and it is used to slow }\par
00192 {\cf20      * down the motors during stop mode}\par
00193 {\cf20      * }\par
00194 {\cf20      * @param inputVelocity between -1 and 1 (double)}\par
00195 {\cf20      * @return the new value (lower)}\par
00196 {\cf20      */}\par
00197     {\cf17 private} {\cf18 double}[] slowDown({\cf18 double}[] inputVelocity)\{\par
00198         {\cf20 // input is between -1 and 1}\par
00199         {\cf18 double}[] newVelocity = {\cf17 new} {\cf18 double}[4];\par
00200 \par
00201         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++)\{\par
00202             {\cf19 if} (Math.abs(inputVelocity[i]) > Constants.SLOW_DOWN_CUTOFF)\{\par
00203                 {\cf20 // velocity still needs to be reduced (magnatude is above cutoff)}\par
00204                 newVelocity[i] = inputVelocity[i] / Constants.SLOW_DOWN_FACTOR;\par
00205             \} {\cf19 else} \{\par
00206                 {\cf20 // input has reached cutoff, now returning 0 speed}\par
00207                 newVelocity[i] = 0;\par
00208             \}\par
00209         \}\par
00210         {\cf19 return} newVelocity;\par
00211     \}\par
00212 \par
00213     @Override\par
00214     {\cf17 public} {\cf18 void} turnOnStopMode() \{\par
00215         {\cf19 if}(currentMode.equals(STOP_MODE)) {\cf19 return};\par
00216         currentMode = STOP_MODE;\par
00217         {\cf20 // Stop mode activated, so now the robot needs to slow down}\par
00218         {\cf20 // start by saving the last left and right velocities }\par
00219         slowingDownSpeeds = combinedSpeeds;\par
00220         System.out.println({\cf22 "STOP MODE"});\par
00221     \}\par
00222 \par
00223     {\cf20 // cycles through the activated wheels during debug mode}\par
00224     {\cf17 public} {\cf18 void} cycleMotorDebugMode() \{\par
00225         debugEnabledMotor++;\par
00226         debugEnabledMotor %= 4;\par
00227         System.out.println({\cf22 "Current Motor: "} + debugEnabledMotor);\par
00228     \}\par
00229 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
robotics/2023DriveBase/src/main/java/frc/robot/subsystems/TankDrive.java File Reference\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/src/main/java/frc/robot/subsystems/TankDrive.java}
{\xe \v robotics/2023DriveBase/src/main/java/frc/robot/subsystems/TankDrive.java}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b frc.robot.subsystems.TankDrive}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages the tank drive base. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Packages\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
package {\b frc.robot.subsystems}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TankDrive.java\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/src/main/java/frc/robot/subsystems/TankDrive.java}
{\xe \v robotics/2023DriveBase/src/main/java/frc/robot/subsystems/TankDrive.java}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf17 package }frc.robot.subsystems;\par
00002 \par
00003 {\cf17 import} javax.print.DocFlavor.STRING;\par
00004 \par
00005 {\cf17 import} com.ctre.phoenix.motorcontrol.ControlMode;\par
00006 {\cf17 import} com.ctre.phoenix.motorcontrol.can.TalonSRX;\par
00007 {\cf17 import} com.ctre.phoenix.motorcontrol.can.VictorSPX;\par
00008 {\cf17 import} frc.robot.Constants;\par
00009 {\cf17 import} com.revrobotics.CANSparkMax;\par
00010 {\cf17 import} com.revrobotics.CANSparkMaxLowLevel;\par
00011 {\cf17 import} com.revrobotics.RelativeEncoder;\par
00012 {\cf17 import} com.revrobotics.SparkMaxRelativeEncoder;\par
00013 {\cf17 import} edu.wpi.first.math.kinematics.DifferentialDriveOdometry;\par
00014 {\cf17 import} edu.wpi.first.math.geometry.Rotation2d;\par
00015 {\cf17 import} com.kauailabs.navx.frc.AHRS;\par
00016 \par
00017 {\cf17 import} edu.wpi.first.math.controller.PIDController;\par
00018 {\cf17 import} edu.wpi.first.math.geometry.Pose2d;\par
00019 {\cf17 import} edu.wpi.first.wpilibj.SPI;\par
00020 {\cf17 import} edu.wpi.first.math.MathUtil;\par
00021 {\cf20 }\par
00022 {\cf20 /**}\par
00023 {\cf20  * Manages the tank drive base}\par
00024 {\cf20  * }\par
00025 {\cf20  */}\par
00026 {\cf17 public} {\cf17 class }TankDrive {\cf17 extends} DriveBase\{\par
00027     \par
00028     {\cf20 // between 0 and 1 - 1 would be full max speed, 0.5 would be half speed, etc}\par
00029     {\cf18 double} maxSpeed = 0.5;\par
00030 \par
00031     {\cf20 // scales the rotational speed of the robot, controlled by the right analog}\par
00032     {\cf18 double} rotationalSpeedMultiplier = 0.75;\par
00033 \par
00034     {\cf20 // define objects}\par
00035     TalonSRX leftTalon, rightTalon;\par
00036     VictorSPX leftVictor, rightVictor;\par
00037     CANSparkMax leftSparkMax;\par
00038     RelativeEncoder sparkMaxEncoder;\par
00039 \par
00040     DifferentialDriveOdometry odometer;\par
00041     AHRS navx;\par
00042 \par
00043     {\cf20 // different modes}\par
00044     String currentMode;\par
00045     {\cf17 final} String DEFAULT_MODE = {\cf22 "DEFAULT"};\par
00046     {\cf17 final} String DEBUG_MODE = {\cf22 "DEBUG"};\par
00047     {\cf17 final} String PID_TUNING_MODE = {\cf22 "PIDTUNING"};\par
00048     {\cf17 final} String STOP_MODE = {\cf22 "STOP"};\par
00049 \par
00050     {\cf20 // Stop mode variables}\par
00051 \par
00052     {\cf20 // to save the last velocities so the robot can slow down}\par
00053     {\cf18 double} slowingLeftVel = 0;\par
00054     {\cf18 double} slowingRightVel = 0;\par
00055 \par
00056     {\cf20 // this makes the left and right vel scope include the function that sets}\par
00057     {\cf20 // the slowing values so the function can use them}\par
00058     {\cf18 double} leftVel;\par
00059     {\cf18 double} rightVel;\par
00060 \par
00061     {\cf20 // PID variables}\par
00062 \par
00063     {\cf20 // amount to increment constant during PID Tuning Mode}\par
00064     {\cf18 double}[] PIDIncrements = \{0.05, 0.05, 0.05\}; {\cf20 // kP, kI, kD increments}\par
00065 \par
00066     {\cf20 // PID constants}\par
00067     {\cf18 double}[] PIDConstants = \{1, 0, 0\}; {\cf20 // kP, kI, kD}\par
00068 \par
00069     {\cf20 // Upper bound for PID constants}\par
00070     {\cf18 double}[] PIDMaximums = \{2, 1, 1\};\par
00071     \par
00072     PIDController leftPID;\par
00073     PIDController rightPID;\par
00074     \par
00075     {\cf20 // current constant to be tuned}\par
00076     {\cf18 int} currentPIDConstant = 0; {\cf20 // 0 = kP, 1 = kI, 2 = kD}\par
00077 \par
00078     {\cf20 // during PID Tuning Mode, either increasing or decreasing the constants by the increment}\par
00079     {\cf18 boolean} increasingPIDConstant = {\cf17 true};\par
00080 \par
00081     {\cf18 double} maxAngularVel = 53; {\cf20 // determined experimentally}\par
00082 {\cf20 }\par
00083 {\cf20     /**}\par
00084 {\cf20      * Constructor for TankDrive Class}\par
00085 {\cf20      * }\par
00086 {\cf20      * @param leftMotorPort}\par
00087 {\cf20      * @param rightMotorPort}\par
00088 {\cf20      */}\par
00089     {\cf17 public} TankDrive({\cf18 int} leftTalonPort, {\cf18 int} leftVictorPort,\par
00090                      {\cf18 int} rightTalonPort, {\cf18 int} rightVictorPort) \{\par
00091         leftVictor = {\cf17 new} VictorSPX(leftVictorPort);\par
00092         leftSparkMax = {\cf17 new} CANSparkMax(leftTalonPort, CANSparkMaxLowLevel.MotorType.kBrushed);\par
00093         rightTalon = {\cf17 new} TalonSRX(rightTalonPort);\par
00094         rightVictor = {\cf17 new} VictorSPX(rightVictorPort);\par
00095         sparkMaxEncoder = leftSparkMax.getEncoder(SparkMaxRelativeEncoder.Type.kQuadrature, Constants.ENCODER_CPR);\par
00096 \par
00097         currentMode = DEFAULT_MODE;\par
00098 \par
00099         leftPID = {\cf17 new} PIDController(PIDConstants[0], PIDConstants[1], PIDConstants[2]);\par
00100         rightPID = {\cf17 new} PIDController(PIDConstants[0], PIDConstants[1], PIDConstants[2]);\par
00101 \par
00102         navx = {\cf17 new} AHRS(SPI.Port.kMXP);\par
00103         odometer = {\cf17 new} DifferentialDriveOdometry({\cf17 new} Rotation2d());\par
00104         resetPosition();\par
00105     \}\par
00106     {\cf20 }\par
00107 {\cf20     /**}\par
00108 {\cf20      * Drive the robot tank base from controller input }\par
00109 {\cf20      * }\par
00110 {\cf20      * These are doubles on the interval [-1,1], and come from the controller's }\par
00111 {\cf20      *  analog sticks (circle spinny things)}\par
00112 {\cf20      * @param leftAnalogX }\par
00113 {\cf20      * @param leftAnalogY }\par
00114 {\cf20      * @param rightAnalogX }\par
00115 {\cf20      * @param rightAnalogY }\par
00116 {\cf20      */}\par
00117     {\cf17 public} {\cf18 void} drive({\cf18 double} leftAnalogX, {\cf18 double} leftAnalogY,\par
00118                       {\cf18 double} rightAnalogX, {\cf18 double} rightAnalogY) \{\par
00119 {\cf20 }\par
00120 {\cf20         /**}\par
00121 {\cf20          * we only care about left Y and right X}\par
00122 {\cf20          * left Y is average velocity}\par
00123 {\cf20          * right X is velocity difference between wheels}\par
00124 {\cf20         */}\par
00125 \par
00126         {\cf18 double} x = rightAnalogX; \par
00127         \par
00128         {\cf18 double} y = leftAnalogY;\par
00129 \par
00130         {\cf19 if}(Math.abs(x) < Constants.ANALOG_DEAD_ZONE && Math.abs(y) < Constants.ANALOG_DEAD_ZONE) {\cf19 return}; {\cf20 // deadzone}\par
00131 \par
00132         {\cf20 // make sure that both velocities are in [-1, 1]}\par
00133         {\cf18 double} preScaledLeftVel = y - x * rotationalSpeedMultiplier;\par
00134         {\cf18 double} preScaledRightVel = y + x * rotationalSpeedMultiplier;\par
00135         {\cf18 double} scaleFactor = 1 / Math.max(Math.max(Math.abs(preScaledLeftVel), Math.abs(preScaledRightVel)), 1);\par
00136         \par
00137         {\cf20 // scale to what the controller asks}\par
00138         leftVel = preScaledLeftVel * scaleFactor * speedMultiplier;\par
00139         rightVel = preScaledRightVel * scaleFactor * speedMultiplier;\par
00140         \par
00141         {\cf20 // // leftTalon.set(ControlMode.PercentOutput, leftVel);}\par
00142         {\cf20 // leftVictor.set(ControlMode.PercentOutput, leftVel);}\par
00143         {\cf20 // leftSparkMax.set(leftVel);}\par
00144         {\cf20 // rightTalon.set(ControlMode.PercentOutput, rightVel);}\par
00145         {\cf20 // rightVictor.set(ControlMode.PercentOutput, rightVel);}\par
00146         {\cf20 // set the motor speeds}\par
00147         {\cf19 if}(currentMode.equals(DEFAULT_MODE) || currentMode.equals(PID_TUNING_MODE)) \{\par
00148             leftVictor.set(ControlMode.PercentOutput, -1 *leftVel);\par
00149             leftSparkMax.set(leftVel);\par
00150             rightTalon.set(ControlMode.PercentOutput, rightVel);\par
00151             rightVictor.set(ControlMode.PercentOutput, rightVel);\par
00152 \par
00153 \par
00154 \par
00155             {\cf20 // PID stuff}\par
00156 \par
00157             {\cf20 // actual angular velocities converted to radians per second}\par
00158             {\cf18 double} leftAngVel = sparkMaxEncoder.getVelocity() * Constants.SPARK_MAX_CONVERSION_FACTOR;\par
00159             {\cf18 double} rightAngVel = rightTalon.getSelectedSensorVelocity() * Constants.TALON_CONVERSION_FACTOR;\par
00160 \par
00161             {\cf20 // normalized (actual) angular velocities}\par
00162             {\cf18 double} normalLeftAngVel = leftAngVel / maxAngularVel;\par
00163             {\cf18 double} normalRightAngVel = rightAngVel / maxAngularVel;\par
00164 \par
00165 \par
00166             {\cf20 // set the motors according to the PID}\par
00167             {\cf18 double} leftPIDValue = leftPID.calculate(normalLeftAngVel, leftVel);\par
00168             {\cf18 double} rightPIDValue = rightPID.calculate(normalRightAngVel, rightVel);\par
00169 \par
00170 \par
00171             leftVictor.set(ControlMode.PercentOutput, -1 * leftPIDValue);\par
00172             leftSparkMax.set(leftPIDValue);\par
00173             \par
00174             {\cf20 // System.out.println("Analog: " + leftAnalogY + ", Input: " + rightVel + ", Measured: " + rightAngVel + ", Normalized: " + normalRightAngVel + ", PID: " + rightPIDValue);}\par
00175             System.out.println({\cf22 "Right: "} + normalRightAngVel + {\cf22 ", Left: "} + normalLeftAngVel);\par
00176 \par
00177 \par
00178             rightTalon.set(ControlMode.PercentOutput, rightPIDValue);\par
00179             rightVictor.set(ControlMode.PercentOutput, rightPIDValue);\par
00180 \par
00181             \par
00182 \par
00183         \} {\cf19 else} {\cf19 if} (currentMode.equals(DEBUG_MODE)) \{\par
00184             {\cf19 switch} (debugEnabledMotor)\{\par
00185                 {\cf19 case} 0:\par
00186                     leftVictor.set(ControlMode.PercentOutput, -1 * leftVel);\par
00187                     {\cf19 break};\par
00188                 {\cf19 case} 1:\par
00189                     rightVictor.set(ControlMode.PercentOutput, rightVel);\par
00190                     {\cf19 break};\par
00191                 {\cf19 case} 2:\par
00192                     rightTalon.set(ControlMode.PercentOutput, rightVel);\par
00193                     {\cf19 break};\par
00194                 {\cf19 case} 3:\par
00195                     leftSparkMax.set(leftVel);\par
00196                     {\cf19 break};\par
00197             \}\par
00198         \} {\cf19 else} {\cf19 if} (currentMode.equals(STOP_MODE))\{\par
00199             {\cf20 // STOP!!!!! set motors to 0}\par
00200             {\cf20 // slower stop}\par
00201             slowingLeftVel = slowDown(slowingLeftVel);\par
00202             slowingRightVel = slowDown(slowingRightVel);\par
00203 \par
00204             leftVictor.set(ControlMode.PercentOutput, -1 *slowingLeftVel);\par
00205             leftSparkMax.set(slowingLeftVel);\par
00206             rightTalon.set(ControlMode.PercentOutput, slowingRightVel);\par
00207             rightVictor.set(ControlMode.PercentOutput, slowingRightVel);\par
00208 \par
00209         \}\par
00210         updatePosition();\par
00211         {\cf20 // System.out.println(rightTalon.getSelectedSensorVelocity()); // clicks per 100ms}\par
00212         {\cf20 // System.out.println(rightTalon.getSelectedSensorVelocity() * 10 * 60 / 4096);}\par
00213         {\cf20 // System.out.println(sparkMaxEncoder.getVelocity()); // actual rpm}\par
00214         {\cf20 // System.out.println("");}\par
00215 \par
00216 \par
00217 \par
00218 \par
00219         {\cf20 // // Print angular velocity and motor use level}\par
00220         {\cf20 // // get rotational speeds from the motors on each side}\par
00221         {\cf20 // // divide by 60 to get rotations per second}\par
00222         {\cf20 // double leftRPS = -1 * sparkMaxEncoder.getVelocity() / 60;}\par
00223 \par
00224         {\cf20 // if (Math.abs(leftRPS) > 0.1)\{}\par
00225         {\cf20 //  // // multiply by 10 because this is per 100ms - we want rps}\par
00226         {\cf20 //  double rightRPS = rightTalon.getSelectedSensorVelocity() * 10 / Constants.ENCODER_CPR;}\par
00227         {\cf20 //  System.out.println("Right Rps: " + rightRPS + "\\nLeft RPS: " + leftRPS);}\par
00228         {\cf20 //  System.out.println("Right velocity from controller: " + rightVel + "\\nLeft Velocity from controller: " + leftVel);}\par
00229         {\cf20 // \}}\par
00230          \par
00231 \par
00232     \}\par
00233 {\cf20 }\par
00234 {\cf20     /**}\par
00235 {\cf20      * This will return a value lower than the input, and it is used to slow }\par
00236 {\cf20      * down the motors during stop mode}\par
00237 {\cf20      * }\par
00238 {\cf20      * @param inputVelocity between -1 and 1 (double)}\par
00239 {\cf20      * @return the new value (lower)}\par
00240 {\cf20      */}\par
00241     {\cf17 private} {\cf18 double} slowDown({\cf18 double} inputVelocity)\{\par
00242         {\cf20 // input is between -1 and 1}\par
00243         {\cf18 double} newVelocity;\par
00244         {\cf19 if} (Math.abs(inputVelocity) > Constants.SLOW_DOWN_CUTOFF)\{\par
00245             {\cf20 // velocity still needs to be reduced (magnatude is above cutoff)}\par
00246             newVelocity = inputVelocity / Constants.SLOW_DOWN_FACTOR;\par
00247         \} {\cf19 else} \{\par
00248             {\cf20 // input has reached cutoff, now returning 0 speed}\par
00249             {\cf19 return} 0;\par
00250         \}\par
00251         {\cf19 return} newVelocity;\par
00252     \}\par
00253 \par
00254     @Override\par
00255     {\cf17 public} {\cf18 void} turnOnStopMode() \{\par
00256         {\cf19 if}(currentMode.equals(STOP_MODE)) {\cf19 return};\par
00257         currentMode = STOP_MODE;\par
00258         {\cf20 // Stop mode activated, so now the robot needs to slow down}\par
00259         {\cf20 // start by saving the last left and right velocities }\par
00260         slowingLeftVel = leftVel;\par
00261         slowingRightVel = rightVel;\par
00262         System.out.println({\cf22 "STOP MODE"});\par
00263     \}\par
00264 \par
00265     {\cf17 public} {\cf18 void} cycleMotorDebugMode() \{\par
00266         debugEnabledMotor++;\par
00267         debugEnabledMotor %= 4;\par
00268         System.out.println({\cf22 "Current Motor: "} + debugEnabledMotor);\par
00269     \}\par
00270 \par
00271     {\cf17 public} {\cf18 void} updateRobotVelocity() \{\par
00272         \par
00273         {\cf20 // get rotational speeds from the motors on each side}\par
00274         {\cf20 // divide by 60 to get rotations per second}\par
00275         {\cf20 // double leftRPS = -1 * sparkMaxEncoder.getVelocity() / 60;}\par
00276         {\cf20 // // multiply by 10 because this is per 100ms - we want rps}\par
00277         {\cf20 // double rightRPS = rightTalon.getSelectedSensorVelocity() * 10 / Constants.ENCODER_CPR;}\par
00278 \par
00279         {\cf20 // // find linear velocities in m/s}\par
00280         {\cf20 // double leftVel = (leftRPS * 2 * Math.PI) * Constants.TANK_WHEEL_RADIUS;}\par
00281         {\cf20 // double rightVel = (rightRPS * 2 * Math.PI) * Constants.TANK_WHEEL_RADIUS;}\par
00282 \par
00283         {\cf20 // currentSpeeds.leftMetersPerSecond = leftVel;}\par
00284         {\cf20 // currentSpeeds.rightMetersPerSecond = rightVel;}\par
00285     \}\par
00286 \par
00287     {\cf17 public} {\cf18 void} getPosition()\par
00288     \{\par
00289 \par
00290     \}\par
00291 \par
00292     {\cf17 public} {\cf18 void} updatePosition()\par
00293     \{\par
00294         {\cf20 // get the linear position of the left wheel and convert to meters}\par
00295         {\cf18 double} leftWheelPos = -1 * sparkMaxEncoder.getPosition() * 2 * Math.PI * Constants.TANK_WHEEL_RADIUS;\par
00296 \par
00297         {\cf20 // get the linear position of the right wheel and convert to meters}\par
00298         {\cf18 double} rightWheelPos = rightTalon.getSelectedSensorPosition() / Constants.ENCODER_CPR * 2 * Math.PI * Constants.TANK_WHEEL_RADIUS;\par
00299 \par
00300         {\cf20 // get the angle of the robot}\par
00301         {\cf18 double} theta = navx.getAngle() / 180 * Math.PI;\par
00302         Rotation2d rot = {\cf17 new} Rotation2d(theta);\par
00303         odometer.update(rot, leftWheelPos, rightWheelPos);\par
00304     \}\par
00305 \par
00306     @Override\par
00307     {\cf17 public} {\cf18 void} AButtonPressed() \{\par
00308         {\cf19 switch}(currentMode) \{\par
00309             {\cf19 case} DEFAULT_MODE:\par
00310                 printPosition();\par
00311                 {\cf19 break};\par
00312             {\cf19 case} DEBUG_MODE:\par
00313                 printPosition();    \par
00314                 {\cf19 break};\par
00315             {\cf19 case} STOP_MODE:\par
00316                 printPosition();    \par
00317                 {\cf19 break};\par
00318             {\cf19 case} PID_TUNING_MODE:\par
00319                 incrementPIDConstant();\par
00320                 {\cf19 break};\par
00321         \}\par
00322     \}\par
00323 \par
00324     @Override\par
00325     {\cf17 public} {\cf18 void} BButtonPressed() \{\par
00326         {\cf19 switch}(currentMode) \{\par
00327             {\cf19 case} DEFAULT_MODE:\par
00328                 resetPosition();\par
00329                 {\cf19 break};\par
00330             {\cf19 case} DEBUG_MODE:\par
00331                 resetPosition();    \par
00332                 {\cf19 break};\par
00333             {\cf19 case} STOP_MODE:\par
00334                 resetPosition();\par
00335                 {\cf19 break};\par
00336             {\cf19 case} PID_TUNING_MODE:\par
00337                 cyclePIDConstant();\par
00338                 {\cf19 break};\par
00339         \}\par
00340     \}\par
00341 \par
00342     @Override\par
00343     {\cf17 public} {\cf18 void} XButtonPressed() \{\par
00344         {\cf19 switch}(currentMode) \{\par
00345             {\cf19 case} PID_TUNING_MODE:\par
00346                 toggleDecreasingPIDIncrement();\par
00347                 {\cf19 break};\par
00348         \}\par
00349     \}\par
00350 \par
00351     @Override\par
00352     {\cf17 public} {\cf18 void} YButtonPressed() \{\par
00353         {\cf19 switch}(currentMode) \{\par
00354             {\cf19 case} PID_TUNING_MODE:\par
00355                 printPIDConstants();\par
00356                 {\cf19 break};\par
00357         \}\par
00358     \}\par
00359 {\cf20 }\par
00360 {\cf20     /**}\par
00361 {\cf20      * PID Tuning Mode: Increments the selected PID constant}\par
00362 {\cf20      */}\par
00363     {\cf17 public} {\cf18 void} incrementPIDConstant() \{\par
00364         {\cf19 if}(increasingPIDConstant) \{\par
00365             PIDConstants[currentPIDConstant] += PIDIncrements[currentPIDConstant];\par
00366         \} {\cf19 else} \{\par
00367             PIDConstants[currentPIDConstant] -= PIDIncrements[currentPIDConstant];\par
00368         \}\par
00369         {\cf20 // make sure constants are in [0, constantMax]}\par
00370         PIDConstants[currentPIDConstant] = Math.min(PIDConstants[currentPIDConstant], PIDMaximums[currentPIDConstant]);\par
00371         PIDConstants[currentPIDConstant] = Math.max(PIDConstants[currentPIDConstant], 0);\par
00372 \par
00373         {\cf20 // print PID constants}\par
00374         System.out.println({\cf22 "kP: "} + PIDConstants[0] + {\cf22 ", kI: "} + PIDConstants[1] + {\cf22 ", kD: "} + PIDConstants[2]);\par
00375 \par
00376         {\cf20 // set PID constant in the PID controllers}\par
00377         {\cf19 if}(currentPIDConstant == 0) \{\par
00378             leftPID.setP(PIDConstants[0]);\par
00379             rightPID.setP(PIDConstants[0]);\par
00380         \} {\cf19 else} {\cf19 if} (currentPIDConstant == 1) \{\par
00381             leftPID.setI(PIDConstants[1]);\par
00382             rightPID.setI(PIDConstants[1]);\par
00383         \} {\cf19 else} {\cf19 if} (currentPIDConstant == 2) \{\par
00384             leftPID.setD(PIDConstants[2]);\par
00385             rightPID.setD(PIDConstants[2]);\par
00386         \}\par
00387     \}\par
00388 {\cf20 }\par
00389 {\cf20     /**}\par
00390 {\cf20      * PID Tuning Mode: Cycles between the PID constants}\par
00391 {\cf20      */}\par
00392     {\cf17 public} {\cf18 void} cyclePIDConstant() \{\par
00393         currentPIDConstant++;\par
00394         currentPIDConstant %= 3;\par
00395         {\cf19 if}(currentPIDConstant == 0) \{\par
00396             System.out.println({\cf22 "kP Selected"});\par
00397         \}\par
00398         {\cf19 else} {\cf19 if}(currentPIDConstant == 1) \{\par
00399             System.out.println({\cf22 "kI Selected"});\par
00400         \}\par
00401         {\cf19 else} {\cf19 if}(currentPIDConstant == 2) \{\par
00402             System.out.println({\cf22 "kD Selected"});\par
00403         \}\par
00404     \}\par
00405 \par
00406     {\cf20 /*}\par
00407 {\cf20      * PID Tuning Mode: Toggles between increasing and decreasing the PID constants on each increment}\par
00408 {\cf20      */}\par
00409     {\cf17 public} {\cf18 void} toggleDecreasingPIDIncrement() \{\par
00410         {\cf19 if}(increasingPIDConstant) \{\par
00411             increasingPIDConstant = {\cf17 false};\par
00412             System.out.println({\cf22 "Decreasing PID Constants"});\par
00413         \} {\cf19 else} \{\par
00414             increasingPIDConstant = {\cf17 true};\par
00415             System.out.println({\cf22 "Increasing PID Constants"});\par
00416         \}\par
00417     \}\par
00418 \par
00419     {\cf17 public} {\cf18 void} printPIDConstants() \{\par
00420         System.out.println({\cf22 "kP: "} + PIDConstants[0] + {\cf22 ", kI: "} + PIDConstants[1] + {\cf22 ", kD: "} + PIDConstants[2]);\par
00421     \}\par
00422 \par
00423     {\cf17 public} {\cf18 void} resetPosition()\par
00424     \{\par
00425         {\cf20 // reset the sensors to zero the position}\par
00426         navx.reset();\par
00427         navx.resetDisplacement();\par
00428         sparkMaxEncoder.setPosition(0);\par
00429         rightTalon.setSelectedSensorPosition(0);\par
00430         odometer.resetPosition({\cf17 new} Pose2d(), {\cf17 new} Rotation2d());\par
00431     \}\par
00432 \par
00433     {\cf17 public} {\cf18 void} printPosition()\par
00434     \{\par
00435         Pose2d posFromWheelDisplacement = odometer.getPoseMeters();\par
00436         System.out.println({\cf22 "Position from odometer and wheel: "});\par
00437         System.out.println({\cf22 "X: "} + posFromWheelDisplacement.getX() + {\cf22 " Y: "} + posFromWheelDisplacement.getY() + {\cf22 " rotation: "} + posFromWheelDisplacement.getRotation());\par
00438 \par
00439         System.out.println({\cf22 "\\nPosition info from navx: "});\par
00440         System.out.println({\cf22 "X: "} + navx.getDisplacementX() + {\cf22 " Y: "} + navx.getDisplacementY() + {\cf22 " rotation: "} + navx.getAngle());\par
00441         System.out.println();\par
00442 \par
00443         {\cf20 // get the linear position of the left wheel and convert to meters}\par
00444         {\cf18 double} leftWheelPos = -1 * sparkMaxEncoder.getPosition() * 2 * Math.PI * Constants.TANK_WHEEL_RADIUS;\par
00445 \par
00446         {\cf20 // get the linear position of the right wheel and convert to meters}\par
00447         {\cf18 double} rightWheelPos = rightTalon.getSelectedSensorPosition() / Constants.ENCODER_CPR * 2 * Math.PI * Constants.TANK_WHEEL_RADIUS;\par
00448         System.out.println({\cf22 "Right Pos: "} + rightWheelPos + {\cf22 " left pos: "} + leftWheelPos);\par
00449 \par
00450 \par
00451         {\cf20 // Print angular velocity and motor use level}\par
00452         {\cf20 // get rotational speeds from the motors on each side}\par
00453         {\cf20 // divide by 60 to get rotations per second}\par
00454         {\cf18 double} leftRPS = -1 * sparkMaxEncoder.getVelocity() / 60;\par
00455         {\cf20 // // multiply by 10 because this is per 100ms - we want rps}\par
00456         {\cf18 double} rightRPS = rightTalon.getSelectedSensorVelocity() * 10 / Constants.ENCODER_CPR;\par
00457         System.out.println({\cf22 "Right Rps: "} + rightRPS + {\cf22 "\\nLeft RPS: "} + leftRPS);\par
00458 \par
00459     \}\par
00460     \par
00461 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
robotics/2023DriveBase/WPILib-License.md File Reference\par \pard\plain 
{\tc\tcl2 \v robotics/2023DriveBase/WPILib-License.md}
{\xe \v robotics/2023DriveBase/WPILib-License.md}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
